#!/usr/bin/env python3
"""
Generate an index of sections and functions from research_notebook_with_code.html

Usage:
    python generate_index.py                    # Full index (markdown)
    python generate_index.py --section NAME     # Single section details
    python generate_index.py --sections         # Just section headers + line counts
    python generate_index.py --json             # Output as JSON (for tooling)

The script parses section markers in both formats:
    // ========== SECTION: NAME ==========       (JavaScript)
    <!-- ========== SECTION: NAME ========== --> (HTML)
and extracts functions with their preceding comments.
"""

import re
import json
import argparse
from pathlib import Path
from dataclasses import dataclass, field, asdict
from typing import Optional


@dataclass
class Function:
    name: str
    line: int
    comment: str = ""
    is_async: bool = False


@dataclass
class Section:
    name: str
    start_line: int
    end_line: int = 0
    line_count: int = 0
    description: str = ""
    functions: list = field(default_factory=list)


def parse_html_file(filepath: Path) -> tuple[list[Section], list[str]]:
    """Parse the HTML file and extract sections and functions."""

    with open(filepath, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    sections = []
    current_section = None

    # Regex patterns
    js_section_pattern = re.compile(r'//\s*=+\s*SECTION:\s*(\w+)\s*=+')
    html_section_pattern = re.compile(r'<!--\s*=+\s*SECTION:\s*(\w+)\s*=+')
    func_pattern = re.compile(r'^        (async\s+)?function\s+(\w+)\s*\(')
    comment_pattern = re.compile(r'^        //\s*(.*)$')

    pending_comment = ""
    last_was_comment = False

    for i, line in enumerate(lines, 1):  # 1-indexed line numbers
        # Check for section marker (JS or HTML comment style)
        section_match = js_section_pattern.search(line) or html_section_pattern.search(line)
        if section_match:
            # Close previous section
            if current_section:
                current_section.end_line = i - 1
                current_section.line_count = current_section.end_line - current_section.start_line + 1
                sections.append(current_section)

            # Start new section
            section_name = section_match.group(1)
            current_section = Section(name=section_name, start_line=i)

            # Check next line for section description
            if i < len(lines):
                next_line = lines[i]  # 0-indexed, so lines[i] is line i+1
                desc_match = comment_pattern.match(next_line)
                if desc_match and not js_section_pattern.search(next_line):
                    current_section.description = desc_match.group(1)

            pending_comment = ""
            last_was_comment = False
            continue

        # Check for function definition
        func_match = func_pattern.match(line)
        if func_match and current_section:
            is_async = bool(func_match.group(1))
            func_name = func_match.group(2)

            # Only use comment if it was immediately preceding
            comment = pending_comment if last_was_comment else ""

            func = Function(
                name=func_name,
                line=i,
                comment=comment,
                is_async=is_async
            )
            current_section.functions.append(func)
            pending_comment = ""
            last_was_comment = False
            continue

        # Track comments - only keep the most recent one directly before a function
        comment_match = comment_pattern.match(line)
        if comment_match:
            comment_text = comment_match.group(1)
            # Skip section markers and dividers
            if not js_section_pattern.search(line) and not line.strip().startswith('// ==='):
                pending_comment = comment_text
                last_was_comment = True
            else:
                last_was_comment = False
        elif line.strip():
            # Non-comment, non-blank line - reset
            pending_comment = ""
            last_was_comment = False
        # Blank lines: keep last_was_comment as True if we just saw a comment

    # Close final section
    if current_section:
        current_section.end_line = len(lines)
        current_section.line_count = current_section.end_line - current_section.start_line + 1
        sections.append(current_section)

    return sections, lines


def format_markdown(sections: list[Section]) -> str:
    """Format sections as markdown."""

    output = []
    output.append("# research_notebook_with_code.html - Section Index\n")
    output.append("*Auto-generated by generate_index.py*\n")
    output.append("\n## Quick Reference\n")
    output.append("| Section | Lines | Start | Description |")
    output.append("|---------|-------|-------|-------------|")

    for s in sections:
        desc = s.description[:50] + "..." if len(s.description) > 50 else s.description
        output.append(f"| {s.name} | {s.line_count} | {s.start_line} | {desc} |")

    output.append("\n---\n")
    output.append("## Sections\n")

    for s in sections:
        output.append(f"### {s.name}")
        output.append(f"**Lines {s.start_line}-{s.end_line}** ({s.line_count} lines)\n")

        if s.description:
            output.append(f"*{s.description}*\n")

        if s.functions:
            output.append("**Functions:**")
            for f in s.functions:
                async_marker = "async " if f.is_async else ""
                comment = f" - {f.comment}" if f.comment else ""
                output.append(f"- `{async_marker}{f.name}()` (line {f.line}){comment}")
        else:
            output.append("*No functions in this section*")

        output.append("")

    return "\n".join(output)


def format_section_detail(section: Section, lines: list[str]) -> str:
    """Format a single section with more detail."""

    output = []
    output.append(f"## {section.name}")
    output.append(f"Lines {section.start_line}-{section.end_line} ({section.line_count} lines)\n")

    if section.description:
        output.append(f"*{section.description}*\n")

    if section.functions:
        output.append("### Functions\n")
        for f in section.functions:
            async_marker = "async " if f.is_async else ""
            output.append(f"**{async_marker}{f.name}()** - line {f.line}")
            if f.comment:
                output.append(f"  {f.comment}")
            output.append("")

    return "\n".join(output)


def format_sections_only(sections: list[Section]) -> str:
    """Format just section headers and line counts."""

    output = []
    output.append("| Section | Lines | Start-End |")
    output.append("|---------|-------|-----------|")

    for s in sections:
        output.append(f"| {s.name} | {s.line_count} | {s.start_line}-{s.end_line} |")

    return "\n".join(output)


def main():
    parser = argparse.ArgumentParser(
        description="Generate index of sections and functions from research_notebook_with_code.html"
    )
    parser.add_argument(
        '--section', '-s',
        type=str,
        help='Show details for a specific section (case-insensitive)'
    )
    parser.add_argument(
        '--sections',
        action='store_true',
        help='Show only section headers and line counts'
    )
    parser.add_argument(
        '--json',
        action='store_true',
        help='Output as JSON'
    )
    parser.add_argument(
        '--file', '-f',
        type=str,
        default='research_notebook_with_code.html',
        help='Path to HTML file (default: research_notebook_with_code.html)'
    )

    args = parser.parse_args()

    # Find the HTML file
    filepath = Path(args.file)
    if not filepath.exists():
        # Try relative to script location
        script_dir = Path(__file__).parent
        filepath = script_dir / args.file

    if not filepath.exists():
        print(f"Error: Could not find {args.file}")
        return 1

    sections, lines = parse_html_file(filepath)

    if args.json:
        # Convert to JSON-serializable format
        data = {
            'file': str(filepath),
            'total_lines': len(lines),
            'sections': [
                {
                    'name': s.name,
                    'start_line': s.start_line,
                    'end_line': s.end_line,
                    'line_count': s.line_count,
                    'description': s.description,
                    'functions': [
                        {
                            'name': f.name,
                            'line': f.line,
                            'comment': f.comment,
                            'is_async': f.is_async
                        }
                        for f in s.functions
                    ]
                }
                for s in sections
            ]
        }
        print(json.dumps(data, indent=2))

    elif args.section:
        # Find matching section (case-insensitive)
        section_name = args.section.upper()
        matching = [s for s in sections if s.name.upper() == section_name]

        if not matching:
            # Try partial match
            matching = [s for s in sections if section_name in s.name.upper()]

        if not matching:
            print(f"Error: No section matching '{args.section}'")
            print(f"Available sections: {', '.join(s.name for s in sections)}")
            return 1

        for section in matching:
            print(format_section_detail(section, lines))

    elif args.sections:
        print(format_sections_only(sections))

    else:
        print(format_markdown(sections))

    return 0


if __name__ == '__main__':
    exit(main())
