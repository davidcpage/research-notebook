---
id: dev-template-system-design
title: Template System Design
author: Claude
created: 2024-12-05T10:00:00Z
modified: 2024-12-10T16:00:00Z
tags: [completed]
---

# Template System Design

*Detailed design for the Research Notebook template system*

## Overview

This document describes a template system that unifies card types (note, code, bookmark) under a common architecture, enabling user-defined card types while simplifying the codebase.

### Design Principles

1. **Files are truth** - Templates are YAML files in the notebook directory, not hidden configuration
2. **Uniformity** - Built-in and custom templates work identically
3. **Extensions define parsing, not templates** - File extensions (`.md`, `.code.py`) determine how to parse, not which template to use
4. **UI is template-driven** - Buttons, modals, and rendering derive from template definitions
5. **CSS via data attributes** - Predictable styling via `[data-template="name"]` selectors

---

## Design Decisions

Key architectural decisions made during the design process:

### 1. Templates Written at Notebook Creation (Not Virtual)

**Decision:** Write `settings.yaml` and `*.template.yaml` files when creating a new notebook, rather than using "virtual" built-in defaults.

*Updated: Extensions are now part of `settings.yaml`, not a separate file.*

**Rationale:**
- Enables template-driven UI (buttons generated from template files)
- Makes the system fully inspectable - users can see exactly what's configured
- Claude can read templates to understand the notebook's structure
- Aligns with TiddlyWiki philosophy where everything is a visible, editable artifact
- Editing templates becomes a standard operation, not "ejecting" from defaults

**Trade-off:** New notebooks have more files (~5 system files), but these are clearly named and serve as documentation.

### 2. Extension Registry Separate from Templates

**Decision:** File extension mappings live in `settings.yaml` (under `extensions:`), separate from template definitions.

*Updated: Originally a separate `extensions.yaml` file, now consolidated into `settings.yaml` for simplicity while maintaining separation of concerns.*

**Rationale:**
- Clean separation of concerns: parsing mechanics vs. presentation/schema
- Extensions can serve multiple templates (`.md` works for `note`, `paper`, etc.)
- Adding new sugar formats is independent from adding new templates
- Single settings file is easier to manage than multiple config files

**Trade-off:** Extensions and notebook metadata share a file, but are clearly separated sections.

### 3. bodyField Owned by Extension, Not Template

**Decision:** The extension registry defines where file body content goes (e.g., `.md` body â†’ `content` field). Templates must conform to this.

**Rationale:**
- Keeps extension semantics fixed and predictable
- A `.md` file always behaves the same way regardless of template
- Templates that want different field names use base format (`.card.yaml`)
- Simpler mental model: "extensions parse, templates present"

**Trade-off:** Less flexibility - a template using `.md` must have a `content` field. But this constraint is honest and clear.

### 4. UI Buttons Generated from Templates

**Decision:** The toolbar's "New X" buttons are generated by reading loaded templates, not hardcoded.

**Rationale:**
- Adding a template automatically adds its button
- Deleting a template removes its button
- Consistent with "files are truth" principle
- `ui.sort_order` in templates controls button ordering

**Trade-off:** Slightly more complex toolbar rendering, but much more extensible.

### 5. Notebook Creation Writes All System Files

**Decision:** New notebook creation writes: `settings.yaml`, `CLAUDE.md`, `README.md`, `.gitignore`, `note.template.yaml`, `code.template.yaml`, `bookmark.template.yaml`.

*Updated: `notebook.json` and `extensions.yaml` consolidated into `settings.yaml`.*

**Rationale:**
- Complete, working notebook from the start
- No "hidden" configuration - everything is visible
- User can immediately customize any aspect
- Claude can read and understand the full notebook structure

**Trade-off:** More files created initially, but provides a solid foundation.

---

## Key Architectural Insight

**Extensions define parsing, templates define meaning.**

This separation keeps the system conceptually clean:

| Concern | Owned By | Examples |
|---------|----------|----------|
| How to parse a file | Extension Registry | `.md` â†’ yaml-frontmatter parser |
| Where body content goes | Extension Registry | `.md` body â†’ `content` field |
| Companion file patterns | Extension Registry | `.code.py` â†’ `.output.html` |
| Default template for extension | Extension Registry | `.md` â†’ `note` template |
| Field schema and types | Template | `content: { type: markdown }` |
| Card/viewer layout | Template | `layout: document` |
| Styling and CSS variables | Template | `--preview-bg: #f0ebe0` |
| Editor configuration | Template | Field order, widgets, actions |

This means:
- Sugar formats (`.md`, `.code.py`) can serve multiple templates via `template:` frontmatter
- Templates don't need to know about file formats - they just define schemas
- Adding a new sugar format is separate from adding a new template
- Both registries are editable system files that users and Claude can read/modify

---

## Implementation Status

| Phase | Status | Notes |
|-------|--------|-------|
| Phase 1: Template Infrastructure | âœ… Complete | Generic loading/saving, template files created on new notebook |
| Phase 2: Generic Rendering | âœ… Complete | Generic card renderer and viewer, CSS with data-template selectors |
| Phase 3: Generic Editor | âœ… Complete | Generic editor modal, template-driven forms, all card types supported |
| Phase 4: Polish | âœ… Complete | Legacy cleanup, settings as system card, yaml layout, template template |

**Result:** ~686 lines removed during legacy cleanup, file reduced from 6397 to 5711 lines.

---

## File Structure

### Notebook Directory Layout

```
notebook/
â”œâ”€â”€ .notebook/
â”‚   â”œâ”€â”€ settings.yaml              # Notebook config (title, subtitle, sections, extensions)
â”‚   â”œâ”€â”€ theme.css                  # Optional: user CSS overrides
â”‚   â””â”€â”€ templates/
â”‚       â”œâ”€â”€ note.yaml              # Note card template
â”‚       â”œâ”€â”€ code.yaml              # Code card template
â”‚       â””â”€â”€ bookmark.yaml          # Bookmark card template
â”œâ”€â”€ CLAUDE.md                      # AI assistant instructions
â”œâ”€â”€ README.md                      # Human-readable description
â””â”€â”€ sections/
    â””â”€â”€ ...
```

---

## Template File Format

### Complete Template Schema

```yaml
# example.template.yaml

# === Identity ===
name: paper                    # Unique identifier (required)
description: "Academic paper summary with structured fields"

# === Schema: Field Definitions ===
schema:
  title:
    type: text
    required: true
  authors:
    type: text
  year:
    type: number
  abstract:
    type: markdown
  # ... other fields

# === Card Display ===
card:
  layout: document             # document | image | split-pane | fields | yaml
  preview_field: abstract      # Which field shows in preview
  title_template: "{{title}} ({{year}})"
  placeholder: "ðŸ“„"

# === Viewer Display ===
viewer:
  layout: sections             # sections | document | split-pane | image | yaml
  sections:
    - label: "Abstract"
      field: abstract
    # ... other sections

# === Editor Configuration ===
editor:
  fields:
    - field: title
      label: "Title"
      width: full
    # ... other fields
  actions:
    - label: "Run"
      action: execute
      icon: "â–¶"

# === Styling ===
style:
  variables:
    --preview-bg: "#f5f0e8"
    --card-border: "#d4c4a8"

# === UI Configuration ===
ui:
  button_label: "Paper"
  icon: "ðŸ“„"
  show_create_button: true
  sort_order: 10
```

### Field Types

| Type | Description | Editor Widget | Display |
|------|-------------|---------------|---------|
| `text` | Plain text | `<input type="text">` | Plain text |
| `markdown` | Markdown content | `<textarea>` | Rendered markdown + LaTeX |
| `url` | URL with optional auto-fetch | `<input type="url">` | Clickable link |
| `thumbnail` | Image with drag-drop upload | Custom upload widget | `<img>` |
| `code` | Source code | `<textarea>` with monospace | Syntax highlighted |
| `html` | Raw HTML (output) | Read-only display | Raw HTML |
| `number` | Numeric value | `<input type="number">` | Formatted number |
| `boolean` | True/false | `<input type="checkbox">` | Yes/No |
| `list` | Array of values | Multi-input widget | List items |
| `yaml` | Nested YAML object | `<textarea>` with monospace | Formatted YAML |

### Layout Presets

**Card Layouts:**
- `document` - Rendered content in preview frame (notes, papers)
- `image` - Image/thumbnail in preview frame (bookmarks)
- `split-pane` - Left/right split (code with output)
- `fields` - Key-value field display
- `yaml` - All schema fields as formatted YAML (settings, templates)

**Viewer Layouts:**
- `document` - Single scrollable content area
- `sections` - Labeled sections for different fields
- `split-pane` - Side-by-side display
- `image` - Large image with metadata
- `yaml` - All schema fields as formatted YAML

---

## CSS Architecture

### Template CSS Variables

Templates define CSS custom properties that both card and viewer inherit:

```css
/* Note template - parchment style */
.card[data-template="note"],
.modal.viewer[data-template="note"] {
    --template-border: #d9d0be;
    --template-bg: #f6f0e2;
    --template-preview-bg: #f0ebe0;
    --template-title-text: #4a4138;
    --template-heading-font: Georgia, serif;
}

/* Code template - dark terminal style */
.card[data-template="code"],
.modal.viewer[data-template="code"] {
    --template-border: #3a3f4a;
    --template-bg: #282c34;
    --template-code-text: #abb2bf;
}
```

### Card/Viewer Consistency Pattern
- **Cards**: 180px preview frame at top, title/metadata below
- **Viewers**: Same layout as cards, just larger (900px width, 60-90vh height)
- **Principle**: Viewers are "zoomed in" versions of cards, not different views

---

## Summary

This template system transforms Research Notebook from a fixed three-type tool into an extensible platform while:

1. **Simplifying the codebase** - Generic loaders/renderers replace type-specific code
2. **Empowering users** - Add card types by creating YAML files
3. **Enabling Claude** - Templates are readable files that explain the notebook's structure
4. **Maintaining compatibility** - Existing notebooks continue working

*See full implementation details in the original TEMPLATE_SYSTEM_DESIGN.md*
