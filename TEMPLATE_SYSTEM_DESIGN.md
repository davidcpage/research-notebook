# Template System Design

*Detailed design for the Research Notebook template system*

## Overview

This document describes a template system that unifies card types (note, code, bookmark) under a common architecture, enabling user-defined card types while simplifying the codebase.

### Design Principles

1. **Files are truth** - Templates are YAML files in the notebook directory, not hidden configuration
2. **Uniformity** - Built-in and custom templates work identically
3. **Extensions define parsing, not templates** - File extensions (`.md`, `.code.py`) determine how to parse, not which template to use
4. **UI is template-driven** - Buttons, modals, and rendering derive from template definitions
5. **CSS via data attributes** - Predictable styling via `[data-template="name"]` selectors

---

## Design Decisions

Key architectural decisions made during the design process:

### 1. Templates Written at Notebook Creation (Not Virtual)

**Decision:** Write `extensions.yaml` and `*.template.yaml` files when creating a new notebook, rather than using "virtual" built-in defaults.

**Rationale:**
- Enables template-driven UI (buttons generated from template files)
- Makes the system fully inspectable - users can see exactly what's configured
- Claude can read templates to understand the notebook's structure
- Aligns with TiddlyWiki philosophy where everything is a visible, editable artifact
- Editing templates becomes a standard operation, not "ejecting" from defaults

**Trade-off:** New notebooks have more files (~5 system files), but these are clearly named and serve as documentation.

### 2. Extension Registry Separate from Templates

**Decision:** File extension mappings live in `extensions.yaml`, completely separate from template definitions.

**Rationale:**
- Clean separation of concerns: parsing mechanics vs. presentation/schema
- Extensions can serve multiple templates (`.md` works for `note`, `paper`, etc.)
- Adding new sugar formats is independent from adding new templates
- Each registry is single-purpose and easier to understand

**Trade-off:** Two files to understand instead of one, but each is simpler.

### 3. bodyField Owned by Extension, Not Template

**Decision:** The extension registry defines where file body content goes (e.g., `.md` body ‚Üí `content` field). Templates must conform to this.

**Rationale:**
- Keeps extension semantics fixed and predictable
- A `.md` file always behaves the same way regardless of template
- Templates that want different field names use base format (`.card.yaml`)
- Simpler mental model: "extensions parse, templates present"

**Trade-off:** Less flexibility - a template using `.md` must have a `content` field. But this constraint is honest and clear.

### 4. UI Buttons Generated from Templates

**Decision:** The toolbar's "New X" buttons are generated by reading loaded templates, not hardcoded.

**Rationale:**
- Adding a template automatically adds its button
- Deleting a template removes its button
- Consistent with "files are truth" principle
- `ui.sort_order` in templates controls button ordering

**Trade-off:** Slightly more complex toolbar rendering, but much more extensible.

### 5. Notebook Creation Writes All System Files

**Decision:** New notebook creation writes: `notebook.json`, `CLAUDE.md`, `README.md`, `.gitignore`, `extensions.yaml`, `note.template.yaml`, `code.template.yaml`, `bookmark.template.yaml`.

**Rationale:**
- Complete, working notebook from the start
- No "hidden" configuration - everything is visible
- User can immediately customize any aspect
- Claude can read and understand the full notebook structure

**Trade-off:** More files created initially, but provides a solid foundation.

---

## File Structure

### Notebook Directory Layout

```
notebook/
‚îú‚îÄ‚îÄ notebook.json              # Notebook metadata (title, subtitle, section order)
‚îú‚îÄ‚îÄ CLAUDE.md                  # AI assistant instructions
‚îú‚îÄ‚îÄ README.md                  # Human-readable description
‚îú‚îÄ‚îÄ .gitignore                 # Git ignore patterns
‚îÇ
‚îú‚îÄ‚îÄ extensions.yaml            # Extension registry (parser mappings)
‚îú‚îÄ‚îÄ note.template.yaml         # Note card template
‚îú‚îÄ‚îÄ code.template.yaml         # Code card template
‚îú‚îÄ‚îÄ bookmark.template.yaml     # Bookmark card template
‚îú‚îÄ‚îÄ paper.template.yaml        # Example: user-created template
‚îÇ
‚îú‚îÄ‚îÄ theme.css                  # Optional: user CSS overrides
‚îÇ
‚îî‚îÄ‚îÄ sections/
    ‚îú‚îÄ‚îÄ research/
    ‚îÇ   ‚îú‚îÄ‚îÄ _section.json
    ‚îÇ   ‚îú‚îÄ‚îÄ my-note.md
    ‚îÇ   ‚îú‚îÄ‚îÄ analysis.code.py
    ‚îÇ   ‚îú‚îÄ‚îÄ analysis.output.html
    ‚îÇ   ‚îî‚îÄ‚îÄ reference.bookmark.json
    ‚îî‚îÄ‚îÄ papers/
        ‚îú‚îÄ‚îÄ _section.json
        ‚îî‚îÄ‚îÄ smith-2024.md      # With template: paper in frontmatter
```

### System Files at Root

| Pattern | Purpose |
|---------|---------|
| `*.template.yaml` | Card type definitions |
| `extensions.yaml` | Extension registry (parser mappings) |
| `*.css` | Styling overrides |
| `*.md` (CLAUDE.md, README.md) | Documentation / system notes |
| `notebook.json` | Notebook metadata |
| `.gitignore` | Git configuration |

---

## Template File Format

### Complete Template Schema

```yaml
# example.template.yaml

# === Identity ===
name: paper                    # Unique identifier (required)
description: "Academic paper summary with structured fields"

# === Schema: Field Definitions ===
schema:
  # Each field has a name and type specification
  title:
    type: text
    required: true

  authors:
    type: text

  year:
    type: number

  doi:
    type: url

  abstract:
    type: markdown

  methodology:
    type: markdown

  key_findings:
    type: markdown

  notes:
    type: markdown

  tags:
    type: list
    item_type: text

# === Card Display ===
card:
  layout: document             # document | image | split-pane | fields
  preview_field: abstract      # Which field shows in preview
  title_template: "{{title}} ({{year}})"      # Optional: custom title format
  subtitle_template: "{{authors}}"            # Optional: subtitle below title
  placeholder: "üìÑ"            # Icon when preview is empty

# === Viewer Display ===
viewer:
  layout: sections             # sections | document | split-pane
  sections:                    # For 'sections' layout
    - label: "Abstract"
      field: abstract
    - label: "Methodology"
      field: methodology
    - label: "Key Findings"
      field: key_findings
    - label: "Notes"
      field: notes

# === Editor Configuration ===
editor:
  # Field display order and grouping in edit modal
  fields:
    - field: title
      label: "Title"
      width: full              # full | half
    - field: authors
      label: "Authors"
      width: half
    - field: year
      label: "Year"
      width: half
    - field: doi
      label: "DOI"
      width: full
    - field: abstract
      label: "Abstract"
      multiline: true
      rows: 4
    - field: methodology
      label: "Methodology"
      multiline: true
      rows: 6
    - field: key_findings
      label: "Key Findings"
      multiline: true
      rows: 6
    - field: notes
      label: "Notes"
      multiline: true
      rows: 8

# === Styling ===
style:
  variables:
    --preview-bg: "#f5f0e8"
    --card-border: "#d4c4a8"
    --accent-color: "#8b7355"
  css_class: paper-card        # Additional class on card element

# === UI Configuration ===
ui:
  button_label: "Paper"        # Text for "+ New" button
  icon: "üìÑ"                   # Optional icon
  show_create_button: true     # Show in toolbar (default: true)
  sort_order: 10               # Button ordering (lower = earlier)
```

### Field Types

| Type | Description | Editor Widget | Display |
|------|-------------|---------------|---------|
| `text` | Plain text | `<input type="text">` | Plain text |
| `markdown` | Markdown content | `<textarea>` | Rendered markdown + LaTeX |
| `url` | URL with optional auto-fetch | `<input type="url">` | Clickable link |
| `thumbnail` | Image with drag-drop upload | Custom upload widget | `<img>` |
| `code` | Source code | `<textarea>` with monospace | Syntax highlighted |
| `html` | Raw HTML (output) | Read-only display | Raw HTML |
| `number` | Numeric value | `<input type="number">` | Formatted number |
| `date` | Date value | `<input type="date">` | Formatted date |
| `datetime` | Date + time | `<input type="datetime-local">` | Formatted datetime |
| `boolean` | True/false | `<input type="checkbox">` | Yes/No or custom |
| `enum` | Fixed choices | `<select>` | Selected value |
| `list` | Array of values | Multi-input widget | Comma-separated or list |

### Layout Presets

**Card Layouts:**

| Layout | Description | Use Case |
|--------|-------------|----------|
| `document` | Rendered content in preview frame | Notes, papers, text-heavy cards |
| `image` | Image/thumbnail in preview frame | Bookmarks, media cards |
| `split-pane` | Left/right split (configurable ratio) | Code with output |
| `fields` | Key-value field display | Metadata-heavy cards |

**Viewer Layouts:**

| Layout | Description | Use Case |
|--------|-------------|----------|
| `document` | Single scrollable content area | Notes |
| `sections` | Labeled sections for different fields | Papers, structured content |
| `split-pane` | Side-by-side display | Code with output |
| `image` | Large image with metadata below | Bookmarks |

---

## Extension Registry

The extension registry defines how file extensions map to parsers, default templates, and field assignments. This is a **separate concern from templates** - extensions define parsing mechanics, templates define schema and presentation.

### Extension Registry File (extensions.yaml)

```yaml
# extensions.yaml - Maps file extensions to parsing behavior

extensions:
  .md:
    parser: yaml-frontmatter
    defaultTemplate: note
    bodyField: content           # Body always goes to 'content' field

  .code.py:
    parser: comment-frontmatter
    defaultTemplate: code
    bodyField: code              # Body always goes to 'code' field
    companionFiles:
      - suffix: .output.html
        field: output

  .bookmark.json:
    parser: json
    defaultTemplate: bookmark
    # No bodyField - JSON has no body, all fields explicit

  .card.yaml:
    parser: yaml
    defaultTemplate: null        # Must specify template: in file
    # No bodyField - YAML has no body, all fields explicit
```

### Key Principle: Extensions Own Parsing Semantics

**Extensions define:**
- Which parser to use
- Default template (can be overridden by `template:` in frontmatter)
- Where the file body goes (`bodyField`)
- Companion file patterns

**Templates define:**
- Field schema and types
- Card/viewer layout
- Styling
- Editor configuration

This separation means:
- `.md` files always put their body in `content` - any template using `.md` must have a `content` field
- A `paper` template using `.md` files accepts this constraint
- Templates wanting different field names use the base `.card.yaml` format

### Template Compatibility with Extensions

A template is compatible with an extension if its schema includes the extension's `bodyField`:

| Extension | bodyField | Compatible Templates |
|-----------|-----------|---------------------|
| `.md` | `content` | note, any template with `content: markdown` |
| `.code.py` | `code` | code, any template with `code: code` |
| `.bookmark.json` | (none) | bookmark, any template (all fields in JSON) |
| `.card.yaml` | (none) | Any template (universal base format) |

### Using Non-Default Templates with Sugar Formats

To use a `.md` file with a `paper` template:

```markdown
---
template: paper
title: Deep Learning for Medical Imaging
authors: Smith et al.
year: 2024
---
# Content

The main content goes here...
```

The `paper` template must have `content: { type: markdown }` in its schema because `.md` files always assign body to `content`.

### Future: User-Editable Extension Registry

The extension registry is a system file that could be edited by users to:
- Add custom extensions (e.g., `.paper.md` ‚Üí defaults to `paper` template)
- Change default templates for existing extensions
- Define new companion file patterns

This would be phased in after the core template system is stable.

---

## Built-in Templates

### note.template.yaml

```yaml
name: note
description: "Markdown note with full formatting support"

# Note: This template is compatible with .md files because it has a 'content' field
# (the extension registry assigns .md body to 'content')

schema:
  title:
    type: text
    required: true
  content:
    type: markdown
    required: true
  created:
    type: datetime
  modified:
    type: datetime

card:
  layout: document
  preview_field: content
  placeholder: "üìù"

viewer:
  layout: document
  content_field: content

editor:
  fields:
    - field: title
      label: "Title"
    - field: content
      label: "Content"
      multiline: true
      rows: 20
      preview: true            # Show preview toggle

style:
  variables:
    --preview-bg: "#f0ebe0"

ui:
  button_label: "Note"
  icon: "üìù"
  sort_order: 1
```

### code.template.yaml

```yaml
name: code
description: "Executable Python code with output"

# Note: This template is compatible with .code.py files because it has a 'code' field
# (the extension registry assigns .code.py body to 'code')
# Companion file .output.html is also defined in the extension registry

schema:
  title:
    type: text
    required: true
  code:
    type: code
    language: python
    required: true
  output:
    type: html
  showOutput:
    type: boolean
    default: true

card:
  layout: split-pane
  slots:
    left:
      field: output
      width: 60%
    right:
      field: code
      width: 40%
  fallback_layout: document    # When no output exists
  fallback_field: code
  placeholder: "üêç"

viewer:
  layout: split-pane
  slots:
    left:
      field: output
      width: 60%
    right:
      field: code
      width: 40%

editor:
  fields:
    - field: title
      label: "Title"
    - field: code
      label: "Code"
      multiline: true
      rows: 20
      monospace: true
  actions:
    - label: "Run"
      action: execute
      icon: "‚ñ∂"

style:
  variables:
    --preview-bg: "#f8faf8"
    --code-bg: "#f5f5f5"

ui:
  button_label: "Code"
  icon: "üêç"
  sort_order: 2
```

### bookmark.template.yaml

```yaml
name: bookmark
description: "Web bookmark with thumbnail and description"

# Note: This template is compatible with .bookmark.json files
# (JSON format has no body, all fields are explicit in the JSON)

schema:
  title:
    type: text
    required: true
  url:
    type: url
    required: true
  description:
    type: markdown
  thumbnail:
    type: thumbnail
    auto_generate: true        # Try to fetch automatically
  favicon:
    type: url
  created:
    type: datetime

card:
  layout: image
  preview_field: thumbnail
  placeholder: "üîó"

viewer:
  layout: image
  image_field: thumbnail
  content_field: description

editor:
  fields:
    - field: title
      label: "Title"
    - field: url
      label: "URL"
      auto_fetch: true         # Fetch metadata on URL entry
    - field: description
      label: "Description"
      multiline: true
      rows: 4
    - field: thumbnail
      label: "Thumbnail"
      widget: thumbnail-upload

style:
  variables:
    --preview-bg: "linear-gradient(135deg, #f8f6f3 0%, #e8e4df 100%)"

ui:
  button_label: "Bookmark"
  icon: "üîó"
  sort_order: 3
```

---

## Card File Formats

### Base Format (.card.yaml)

The universal format that works for any template:

```yaml
# my-card.card.yaml
template: paper
id: abc123
title: "Deep Learning for Medical Imaging"
authors: "Smith, J. and Jones, M."
year: 2024
doi: "https://doi.org/10.1234/example"
abstract: |
  This paper presents a novel approach to...
methodology: |
  We collected data from...
key_findings: |
  1. Finding one
  2. Finding two
notes: |
  Interesting paper, relates to [[Other Note]]
created: 2024-12-07T10:00:00Z
modified: 2024-12-07T14:30:00Z
```

### Sugar Format: Markdown (.md)

For templates with markdown body content:

```markdown
---
template: paper
id: abc123
title: Deep Learning for Medical Imaging
authors: Smith, J. and Jones, M.
year: 2024
doi: https://doi.org/10.1234/example
abstract: |
  This paper presents a novel approach to...
methodology: |
  We collected data from...
key_findings: |
  1. Finding one
  2. Finding two
created: 2024-12-07T10:00:00Z
modified: 2024-12-07T14:30:00Z
---
# Notes

Interesting paper, relates to [[Other Note]]

The methodology section is particularly relevant to our work on...
```

The body after `---` goes into the `bodyField` defined by the **extension registry** for `.md` files, which is `content`. This means a `paper` template using `.md` files must have a `content` field in its schema.

**Default template inference:** If `template:` is omitted from frontmatter, the extension registry's `defaultTemplate` is used:
- `.md` files default to `note` template
- `.code.py` files default to `code` template
- `.bookmark.json` files default to `bookmark` template
- `.card.yaml` files require explicit `template:` field

### Sugar Format: Python (.code.py)

```python
# title: Data Analysis
# id: xyz789
# created: 2024-12-07T10:00:00Z
# ---

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('data.csv')
print(df.describe())

plt.figure(figsize=(10, 6))
df.plot(kind='bar')
plt.show()
```

Comment lines at the top (before `# ---`) are parsed as frontmatter.
The `template:` field defaults to `code` for `.code.py` files.

Companion file `data-analysis.output.html` stores execution output.

### Sugar Format: JSON (.bookmark.json)

```json
{
  "template": "bookmark",
  "id": "def456",
  "title": "Example Article",
  "url": "https://example.com/article",
  "description": "An interesting article about...",
  "thumbnail": "assets/thumbnails/def456.png",
  "created": "2024-12-07T10:00:00Z"
}
```

The `template:` field defaults to `bookmark` for `.bookmark.json` files.

---

## Data Model

### In-Memory Card Representation

All cards, regardless of source format, normalize to this structure:

```javascript
{
  // Identity
  id: "abc123",                    // Unique identifier
  template: "note",                // Template name

  // Source tracking
  _source: {
    filename: "my-note.md",        // Original filename
    format: "yaml-frontmatter",    // How it was parsed
    section: "research"            // Which section it's in
  },

  // Template-defined fields (varies by template)
  title: "My Note",
  content: "# Heading\n\nSome content...",
  created: "2024-12-07T10:00:00Z",
  modified: "2024-12-07T14:30:00Z",

  // ... other fields defined by template schema
}
```

### Template Registry

```javascript
const templateRegistry = {
  // Loaded templates indexed by name (from *.template.yaml files)
  templates: {
    note: { /* parsed note.template.yaml */ },
    code: { /* parsed code.template.yaml */ },
    bookmark: { /* parsed bookmark.template.yaml */ },
    paper: { /* parsed paper.template.yaml */ }
  }
};
```

### Extension Registry

```javascript
// Loaded from extensions.yaml (or hardcoded defaults)
const extensionRegistry = {
  '.md': {
    parser: 'yaml-frontmatter',
    defaultTemplate: 'note',
    bodyField: 'content'
  },
  '.code.py': {
    parser: 'comment-frontmatter',
    defaultTemplate: 'code',
    bodyField: 'code',
    companionFiles: [
      { suffix: '.output.html', field: 'output' }
    ]
  },
  '.bookmark.json': {
    parser: 'json',
    defaultTemplate: 'bookmark'
  },
  '.card.yaml': {
    parser: 'yaml',
    defaultTemplate: null  // Must specify template: in file
  }
};
```

### Notebook Data Structure

```javascript
const data = {
  // Notebook metadata
  title: "Research Notebook",
  subtitle: "My research notes",

  // Sections with items
  sections: [
    {
      id: "sec-abc",
      name: "Research",
      items: [
        // Normalized card objects
        { id: "card-1", template: "note", title: "...", content: "...", ... },
        { id: "card-2", template: "code", title: "...", code: "...", ... },
        { id: "card-3", template: "bookmark", title: "...", url: "...", ... }
      ]
    }
  ],

  // System notes (top-level .md files like CLAUDE.md)
  systemNotes: [
    { id: "sys-1", filename: "CLAUDE.md", title: "CLAUDE", content: "...", format: "markdown" },
    { id: "sys-2", filename: "README.md", title: "README", content: "...", format: "markdown" }
  ]
};
```

---

## Loading Pipeline

### 1. Load Extension Registry and Templates (on notebook open)

```javascript
async function loadExtensionRegistry(rootHandle) {
  // Try to load user's extensions.yaml
  const extFile = await tryReadFile(rootHandle, 'extensions.yaml');
  if (extFile) {
    return parseYAML(extFile).extensions;
  }
  // Fall back to built-in defaults
  return BUILTIN_EXTENSION_REGISTRY;
}

async function loadTemplates(rootHandle) {
  const templates = {};

  // Scan root directory for .template.yaml files
  for await (const [name, handle] of rootHandle.entries()) {
    if (name.endsWith('.template.yaml')) {
      const content = await readFile(handle);
      const template = parseYAML(content);
      templates[template.name] = template;
    }
  }

  return templates;
}
```

### 2. Card Loading (per file)

```javascript
async function loadCard(filename, content, sectionName, sectionHandle) {
  // 1. Look up extension config from extension registry
  const ext = getExtension(filename);  // e.g., '.md', '.code.py'
  const extConfig = extensionRegistry[ext];

  if (!extConfig) {
    console.warn(`Unknown extension: ${ext}`);
    return null;
  }

  // 2. Parse file using the extension's parser
  const parser = parsers[extConfig.parser];
  const { frontmatter, body } = parser.parse(content);

  // 3. Determine template (frontmatter overrides extension default)
  const templateName = frontmatter.template || extConfig.defaultTemplate;

  if (!templateName) {
    console.warn(`No template specified and no default for ${ext}`);
    return null;
  }

  const template = templateRegistry.templates[templateName];
  if (!template) {
    console.warn(`Unknown template: ${templateName}`);
    return null;
  }

  // 4. Assign body to bodyField (defined by extension, not template)
  if (body && extConfig.bodyField) {
    frontmatter[extConfig.bodyField] = body;
  }

  // 5. Load companion files (defined by extension, not template)
  if (extConfig.companionFiles) {
    for (const companion of extConfig.companionFiles) {
      const companionFilename = replaceExtension(filename, companion.suffix);
      const companionContent = await tryReadFile(sectionHandle, companionFilename);
      if (companionContent) {
        frontmatter[companion.field] = companionContent;
      }
    }
  }

  // 6. Generate ID if missing
  if (!frontmatter.id) {
    frontmatter.id = generateId();
  }

  // 7. Return normalized card
  return {
    template: templateName,
    _source: { filename, format: extConfig.parser, section: sectionName },
    ...frontmatter
  };
}
```

### 3. Parsers

```javascript
const parsers = {
  'yaml-frontmatter': {
    parse(content) {
      const match = content.match(/^---\n([\s\S]*?)\n---\n?([\s\S]*)$/);
      if (match) {
        return {
          frontmatter: parseYAML(match[1]),
          body: match[2].trim() || null
        };
      }
      // No frontmatter, entire content is body
      return { frontmatter: {}, body: content };
    }
  },

  'comment-frontmatter': {
    parse(content) {
      const lines = content.split('\n');
      const frontmatter = {};
      let bodyStart = 0;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line === '# ---') {
          bodyStart = i + 1;
          break;
        }
        const match = line.match(/^# (\w+):\s*(.*)$/);
        if (match) {
          frontmatter[match[1]] = match[2];
        } else if (line.trim() && !line.startsWith('#')) {
          bodyStart = i;
          break;
        }
      }

      return {
        frontmatter,
        body: lines.slice(bodyStart).join('\n').trim() || null
      };
    }
  },

  'json': {
    parse(content) {
      return { frontmatter: JSON.parse(content), body: null };
    }
  },

  'yaml': {
    parse(content) {
      return { frontmatter: parseYAML(content), body: null };
    }
  }
};
```

---

## Saving Pipeline

### 1. Determine Output Format

```javascript
function getSaveFormat(card) {
  // If card was loaded from a file, preserve that format
  if (card._source?.format) {
    return {
      format: card._source.format,
      filename: card._source.filename,
      extension: getExtension(card._source.filename)
    };
  }

  // For new cards, find the extension that defaults to this template
  const ext = findExtensionForTemplate(card.template);
  if (ext) {
    return {
      format: extensionRegistry[ext].parser,
      filename: generateFilename(card.title, ext),
      extension: ext
    };
  }

  // Fallback to base format
  return {
    format: 'yaml',
    filename: generateFilename(card.title, '.card.yaml'),
    extension: '.card.yaml'
  };
}

function findExtensionForTemplate(templateName) {
  // Find extension whose defaultTemplate matches
  for (const [ext, config] of Object.entries(extensionRegistry)) {
    if (config.defaultTemplate === templateName) {
      return ext;
    }
  }
  return null;
}
```

### 2. Serialize Card

```javascript
function serializeCard(card, saveFormat) {
  const { format, extension } = saveFormat;
  const extConfig = extensionRegistry[extension];

  // Remove internal fields
  const { _source, ...data } = card;

  // Extract body field if extension defines one (for sugar formats)
  let body = null;
  const frontmatter = { ...data };

  if (extConfig?.bodyField && format !== 'yaml' && format !== 'json') {
    body = frontmatter[extConfig.bodyField];
    delete frontmatter[extConfig.bodyField];
  }

  // Remove template field if it matches extension's default
  // (e.g., .md files don't need template: note)
  if (extConfig?.defaultTemplate === frontmatter.template) {
    delete frontmatter.template;
  }

  return serializers[format].serialize(frontmatter, body);
}

const serializers = {
  'yaml-frontmatter': {
    serialize(frontmatter, body) {
      const yaml = serializeYAML(frontmatter);
      if (body) {
        return `---\n${yaml}---\n\n${body}`;
      }
      return `---\n${yaml}---\n`;
    }
  },

  'comment-frontmatter': {
    serialize(frontmatter, body) {
      const lines = Object.entries(frontmatter)
        .map(([k, v]) => `# ${k}: ${v}`);
      lines.push('# ---');
      if (body) {
        lines.push('', body);
      }
      return lines.join('\n');
    }
  },

  'json': {
    serialize(frontmatter, body) {
      return JSON.stringify(frontmatter, null, 2);
    }
  },

  'yaml': {
    serialize(frontmatter, body) {
      return serializeYAML(frontmatter);
    }
  }
};
```

### 3. Save Card and Companion Files

```javascript
async function saveCard(card, sectionHandle) {
  const saveFormat = getSaveFormat(card);
  const { format, filename, extension } = saveFormat;
  const extConfig = extensionRegistry[extension];

  const content = serializeCard(card, saveFormat);

  // Save main file
  await writeFile(sectionHandle, filename, content);

  // Save companion files (defined by extension registry)
  if (extConfig?.companionFiles) {
    for (const companion of extConfig.companionFiles) {
      const value = card[companion.field];
      if (value) {
        const companionFilename = replaceExtension(filename, companion.suffix);
        await writeFile(sectionHandle, companionFilename, value);
      }
    }
  }

  // Update source tracking
  card._source = { filename, format, section: sectionHandle.name };
}
```

---

## CSS Architecture

### Data Attribute Selectors

```html
<!-- Card -->
<div class="card" data-template="note" data-id="abc123">
  <div class="card-preview">...</div>
  <div class="card-title">Note Title</div>
  <div class="card-meta">Modified: Dec 7, 2024</div>
  <div class="card-actions">...</div>
</div>

<!-- Viewer -->
<div class="modal viewer" data-template="note">
  <div class="viewer-header">...</div>
  <div class="viewer-content">...</div>
  <div class="viewer-footer">...</div>
</div>
```

### Base Styles (embedded in HTML)

```css
/* === Card Base === */
.card {
  background: var(--card-bg, white);
  border: 1px solid var(--card-border, #e0e0e0);
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  transition: box-shadow 0.2s;
}

.card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.card-preview {
  height: 180px;
  overflow: hidden;
  background: var(--preview-bg, #f5f5f5);
}

.card-title {
  padding: 12px;
  font-weight: 600;
  font-size: 14px;
}

.card-meta {
  padding: 0 12px 12px;
  font-size: 12px;
  color: #666;
}

.card-actions {
  display: none;
  position: absolute;
  top: 8px;
  right: 8px;
}

.card:hover .card-actions {
  display: flex;
  gap: 4px;
}

/* === Template-Specific === */
.card[data-template="note"] {
  --preview-bg: #f0ebe0;
}

.card[data-template="code"] {
  --preview-bg: #f8faf8;
}

.card[data-template="code"] .card-preview {
  font-family: 'SF Mono', Monaco, monospace;
  font-size: 11px;
}

.card[data-template="bookmark"] {
  --preview-bg: linear-gradient(135deg, #f8f6f3 0%, #e8e4df 100%);
}

/* === Viewer Base === */
.viewer {
  max-width: 900px;
  max-height: 90vh;
}

.viewer-header {
  padding: 16px 20px;
  border-bottom: 1px solid #eee;
}

.viewer-content {
  padding: 20px;
  overflow-y: auto;
  min-height: 60vh;
}

.viewer-footer {
  padding: 16px 20px;
  border-top: 1px solid #eee;
  display: flex;
  justify-content: space-between;
}
```

### Template CSS Variables

Templates inject their `style.variables` as CSS:

```javascript
function injectTemplateStyles(templates) {
  const rules = Object.values(templates).map(t => {
    if (!t.style?.variables) return '';

    const vars = Object.entries(t.style.variables)
      .map(([k, v]) => `${k}: ${v};`)
      .join('\n  ');

    return `.card[data-template="${t.name}"],
.viewer[data-template="${t.name}"] {
  ${vars}
}`;
  });

  const style = document.createElement('style');
  style.id = 'template-styles';
  style.textContent = rules.join('\n\n');
  document.head.appendChild(style);
}
```

### User CSS (theme.css)

Loaded after built-in and template styles, can override anything:

```css
/* theme.css - User customizations */

/* Change note preview background */
.card[data-template="note"] {
  --preview-bg: #e8e0d0;
}

/* Custom paper template styling */
.card[data-template="paper"] {
  --preview-bg: #f5f0e6;
  --card-border: #c9b99a;
}

.card[data-template="paper"] .card-preview {
  border-left: 3px solid var(--accent-color, #8b7355);
}

/* Viewer customization */
.viewer[data-template="paper"] .viewer-content section {
  border-bottom: 1px solid #eee;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
```

---

## UI Integration

### Template-Driven Toolbar

```javascript
function renderToolbar() {
  const templates = Object.values(templateRegistry.templates)
    .filter(t => t.ui?.show_create_button !== false)
    .sort((a, b) => (a.ui?.sort_order || 99) - (b.ui?.sort_order || 99));

  const buttons = templates.map(t => `
    <button class="toolbar-btn" onclick="openNewCardModal('${t.name}')">
      ${t.ui?.icon ? `<span class="btn-icon">${t.ui.icon}</span>` : ''}
      <span class="btn-label">+ ${t.ui?.button_label || capitalize(t.name)}</span>
    </button>
  `);

  return `
    <div class="toolbar">
      ${buttons.join('')}
      <div class="toolbar-spacer"></div>
      <button class="toolbar-btn toolbar-btn-muted" onclick="openSettingsModal()">
        ‚öô
      </button>
    </div>
  `;
}
```

### Generic Card Modal

```javascript
function openNewCardModal(templateName) {
  const template = templateRegistry.templates[templateName];

  // Build form fields from template.editor.fields
  const fields = template.editor.fields.map(f => {
    const fieldDef = template.schema[f.field];
    return renderFieldEditor(f, fieldDef);
  });

  // Build actions from template.editor.actions
  const actions = (template.editor.actions || []).map(a => `
    <button class="modal-action" onclick="handleEditorAction('${a.action}')">
      ${a.icon || ''} ${a.label}
    </button>
  `);

  showModal({
    title: `New ${template.ui?.button_label || template.name}`,
    content: `<form id="card-editor-form">${fields.join('')}</form>`,
    footer: `
      <div class="modal-actions">${actions.join('')}</div>
      <div class="modal-buttons">
        <button onclick="closeModal()">Cancel</button>
        <button class="primary" onclick="saveCard()">Save</button>
      </div>
    `
  });
}

function renderFieldEditor(fieldConfig, fieldDef) {
  const { field, label, width, multiline, rows, monospace, preview } = fieldConfig;

  const widthClass = width === 'half' ? 'field-half' : 'field-full';
  const inputId = `field-${field}`;

  let input;
  switch (fieldDef.type) {
    case 'text':
    case 'url':
      input = `<input type="${fieldDef.type === 'url' ? 'url' : 'text'}"
                      id="${inputId}" name="${field}">`;
      break;

    case 'markdown':
    case 'code':
      const style = monospace ? 'font-family: monospace;' : '';
      input = `<textarea id="${inputId}" name="${field}"
                         rows="${rows || 6}" style="${style}"></textarea>`;
      if (preview) {
        input += `<div class="field-preview" id="${inputId}-preview"></div>`;
      }
      break;

    case 'number':
      input = `<input type="number" id="${inputId}" name="${field}">`;
      break;

    case 'boolean':
      input = `<input type="checkbox" id="${inputId}" name="${field}">`;
      break;

    case 'thumbnail':
      input = renderThumbnailUploader(inputId, field);
      break;

    // ... other types
  }

  return `
    <div class="form-field ${widthClass}">
      <label for="${inputId}">${label}</label>
      ${input}
    </div>
  `;
}
```

### Generic Card Renderer

```javascript
function renderCard(card) {
  const template = templateRegistry.templates[card.template];
  if (!template) {
    console.warn(`Unknown template: ${card.template}`);
    return '';
  }

  const preview = renderCardPreview(card, template);
  const title = renderCardTitle(card, template);
  const meta = renderCardMeta(card, template);

  return `
    <div class="card"
         data-template="${card.template}"
         data-id="${card.id}"
         onclick="openViewer('${card.id}')">
      <div class="card-preview">${preview}</div>
      <div class="card-title">${escapeHtml(title)}</div>
      <div class="card-meta">${meta}</div>
    </div>
  `;
}

function renderCardPreview(card, template) {
  const layout = template.card.layout;

  switch (layout) {
    case 'document': {
      const field = template.card.preview_field;
      const content = card[field];
      if (!content) return `<div class="preview-placeholder">${template.card.placeholder || ''}</div>`;

      const fieldDef = template.schema[field];
      if (fieldDef.type === 'markdown') {
        return `<div class="preview-markdown">${renderMarkdown(content)}</div>`;
      }
      return `<div class="preview-text">${escapeHtml(content)}</div>`;
    }

    case 'image': {
      const field = template.card.preview_field;
      const src = card[field];
      if (!src) return `<div class="preview-placeholder">${template.card.placeholder || ''}</div>`;
      return `<img src="${escapeHtml(src)}" class="preview-image">`;
    }

    case 'split-pane': {
      const { left, right } = template.card.slots;
      const leftContent = card[left.field];
      const rightContent = card[right.field];

      if (!leftContent && template.card.fallback_layout) {
        // Fall back to simpler layout if left pane is empty
        return renderCardPreview(card, {
          ...template,
          card: { ...template.card, layout: template.card.fallback_layout }
        });
      }

      return `
        <div class="preview-split">
          <div class="preview-split-left" style="width: ${left.width}">
            ${renderFieldContent(leftContent, template.schema[left.field])}
          </div>
          <div class="preview-split-right" style="width: ${right.width}">
            ${renderFieldContent(rightContent, template.schema[right.field])}
          </div>
        </div>
      `;
    }

    case 'fields': {
      // Key-value display
      const fields = template.card.preview_fields || Object.keys(template.schema).slice(0, 3);
      return fields.map(f => `
        <div class="preview-field">
          <span class="preview-field-label">${f}:</span>
          <span class="preview-field-value">${escapeHtml(card[f] || '')}</span>
        </div>
      `).join('');
    }
  }
}
```

---

## Implementation Plan

### Implementation Status

| Phase | Status | Notes |
|-------|--------|-------|
| Phase 1: Template Infrastructure | ‚úÖ Complete | Generic loading/saving, template files created on new notebook |
| Phase 2: Generic Rendering | ‚úÖ Complete | Generic card renderer and viewer, CSS with data-template selectors |
| Phase 3: Generic Editor | ‚è≥ Not started | Still using type-specific modals |
| Phase 4: Polish | ‚è≥ Not started | |

**Phase 1 Implementation Details:**

- ‚úÖ `loadExtensionRegistry()` - Parses `extensions.yaml`, falls back to `getDefaultExtensionRegistry()`
- ‚úÖ `loadTemplates()` - Parses `*.template.yaml` files, falls back to `getDefaultTemplates()`
- ‚úÖ `loadCard()` - Generic card loader using extension registry for parser selection
- ‚úÖ `serializeCard()` - Generic serializer using extension registry
- ‚úÖ `saveCardFile()` - Generic save function handling all card types + companion files
- ‚úÖ `ensureTemplateFiles()` - Creates template files for new notebooks only
- ‚úÖ `renderTemplateButtons()` - Generates "+ Note/Code/Bookmark" buttons from `templateRegistry`
- ‚úÖ New notebooks get default "Research" section with all template buttons
- ‚úÖ YAML files (`.yaml`, `.template.yaml`) visible as editable system cards

**Phase 2 Implementation Details:**

- ‚úÖ `renderCard()` - Generic card renderer using template definitions
- ‚úÖ Layout renderers: `renderDocumentPreview()`, `renderImagePreview()`, `renderSplitPanePreview()`, `renderFieldsPreview()`
- ‚úÖ `openViewer()` - Generic viewer modal that adapts to any template
- ‚úÖ Viewer layouts: `renderViewerDocument()`, `renderViewerImage()`, `renderViewerSplitPane()`, `renderViewerSections()`
- ‚úÖ `renderViewerActions()` - Template-driven action buttons (Run for code, Open for bookmarks)
- ‚úÖ CSS refactored to use `.card[data-template="..."]` and `.modal.viewer[data-template="..."]` selectors
- ‚úÖ `loadThemeCss()` - Loads optional `theme.css` from notebook directory
- ‚úÖ `injectTemplateStyles()` - Injects CSS variables from template style definitions
- ‚úÖ `render()` updated to use generic `renderCard()` for all items
- ‚úÖ `navigateToItem()` updated to use generic `openViewer()`
- ‚úÖ Generic viewer modal HTML added (`#viewerModal`)
- ‚úÖ Legacy type-specific viewers retained for backwards compatibility during transition

**Code Location:** TEMPLATE_SYSTEM section in `research_notebook_with_code.html` (lines ~2655-3250)

---

### Phase 1: Template Infrastructure

**Goal:** Load templates and extension registry from files, maintain backward compatibility

1. **Extension registry loader** ‚úÖ
   - Parse `extensions.yaml` from notebook root
   - Fall back to hardcoded defaults if missing
   - Build parser and extension mappings

2. **Template loader** ‚úÖ
   - Parse `*.template.yaml` files from notebook root
   - Build template registry
   - Fall back gracefully if templates missing (use hardcoded defaults)

3. **Refactor card loading** ‚úÖ
   - Replace `loadNoteFile()`, `loadCodeFile()`, `loadBookmarkFile()` with generic `loadCard()`
   - Use extension registry for parser selection and body field assignment
   - Support `template:` field in frontmatter to override defaults

4. **Refactor card saving** ‚úÖ
   - Replace type-specific save functions with generic `saveCard()`
   - Use extension registry for format selection and companion files
   - Preserve original format when editing existing cards

5. **Write default system files** ‚úÖ
   - Create `extensions.yaml` with built-in extension mappings
   - Create `note.template.yaml`, `code.template.yaml`, `bookmark.template.yaml`
   - Update notebook creation to write all system files

**Deliverable:** Existing functionality works, driven by extension registry and template files instead of hardcoded logic.

### Phase 2: Generic Rendering

**Goal:** Card and viewer rendering driven by templates

1. **Generic card renderer** ‚úÖ
   - Replace `renderNoteCard()`, `renderCodeCard()`, `renderBookmarkCard()` with `renderCard()`
   - Implement layout renderers (document, image, split-pane, fields)
   - Apply template CSS variables

2. **Generic viewer** ‚úÖ
   - Single viewer modal that adapts to template
   - Implement viewer layouts (document, sections, split-pane, image)
   - Template-driven action buttons

3. **CSS refactoring** ‚úÖ
   - Convert existing styles to use `[data-template="..."]` selectors
   - Extract template-specific variables
   - Support `theme.css` loading

**Deliverable:** All rendering driven by templates. Adding a new template shows cards/viewers automatically.

### Phase 3: Generic Editor

**Goal:** Edit modal generated from template schema

1. **Field editor components**
   - Text input, textarea, URL input, number input
   - Markdown editor with preview toggle
   - Code editor with monospace font
   - Thumbnail uploader with drag-drop
   - Date/datetime pickers

2. **Generic edit modal**
   - Build form from `template.editor.fields`
   - Validate against schema
   - Handle template-specific actions (e.g., "Run" for code)

3. **Template-driven toolbar**
   - Generate "+ New X" buttons from loaded templates
   - Respect `ui.show_create_button` and `ui.sort_order`

**Deliverable:** New card types work end-to-end just by adding a template file.

### Phase 4: Polish and Documentation

1. **Settings UI**
   - Show loaded templates
   - Edit template files (or link to them)
   - Manage `theme.css`

2. **Error handling**
   - Graceful handling of malformed templates
   - Validation warnings for unknown fields
   - Migration helpers for old notebooks

3. **Documentation**
   - Template authoring guide
   - Field type reference
   - CSS customization guide

**Deliverable:** Production-ready template system with good UX for customization.

---

## Migration Strategy

### Existing Notebooks

Notebooks created before the template system will lack system files. The migration approach:

1. **On first open after upgrade:**
   - Detect missing `extensions.yaml` and `*.template.yaml` files
   - Show a one-time message: "Upgrading notebook to template system..."
   - Automatically create all missing system files with defaults
   - Existing cards continue to work unchanged

2. **No data migration needed:**
   - Card file formats are unchanged (`.md`, `.code.py`, `.bookmark.json`)
   - Templates and extension registry are purely additive
   - Old notebooks work immediately after system files are created

3. **User experience:**
   - Migration is automatic and non-destructive
   - User sees new system files appear in notebook root
   - All existing functionality preserved
   - New template customization capabilities immediately available

### Backwards Compatibility

- During Phase 1: if system files are missing, use hardcoded fallbacks
- Extension defaults (`.md` ‚Üí note) match current behavior exactly
- Existing frontmatter fields are preserved even if not in template schema
- Cards with unknown `template:` values fall back to extension default

### Testing Migration

Before releasing template system:
1. Test with notebooks created before upgrade
2. Verify all existing cards load and display correctly
3. Verify save/edit preserves original file format
4. Verify new cards created post-upgrade work correctly

---

## Future Considerations

### Template Inheritance

```yaml
name: paper
extends: note
schema:
  # Inherits title, content, created, modified from note
  authors: { type: text }
  year: { type: number }
```

### Template Variants

```yaml
name: note
variants:
  minimal:
    card:
      layout: fields
      preview_fields: [title]
  full:
    card:
      layout: document
```

### Cross-Template Queries

The Python notebook API could query across templates:

```python
import notebook
papers = notebook.query(template='paper', year__gte=2020)
```

### Template Marketplace

Community-shared templates could be installed by copying `.template.yaml` files.

---

## Summary

This template system transforms Research Notebook from a fixed three-type tool into an extensible platform while:

1. **Simplifying the codebase** - Generic loaders/renderers replace type-specific code
2. **Empowering users** - Add card types by creating YAML files
3. **Enabling Claude** - Templates are readable files that explain the notebook's structure
4. **Maintaining compatibility** - Existing notebooks continue working

### Key Architectural Insight

**Extensions define parsing, templates define meaning.**

This separation keeps the system conceptually clean:

| Concern | Owned By | Examples |
|---------|----------|----------|
| How to parse a file | Extension Registry | `.md` ‚Üí yaml-frontmatter parser |
| Where body content goes | Extension Registry | `.md` body ‚Üí `content` field |
| Companion file patterns | Extension Registry | `.code.py` ‚Üí `.output.html` |
| Default template for extension | Extension Registry | `.md` ‚Üí `note` template |
| Field schema and types | Template | `content: { type: markdown }` |
| Card/viewer layout | Template | `layout: document` |
| Styling and CSS variables | Template | `--preview-bg: #f0ebe0` |
| Editor configuration | Template | Field order, widgets, actions |

This means:
- Sugar formats (`.md`, `.code.py`) can serve multiple templates via `template:` frontmatter
- Templates don't need to know about file formats - they just define schemas
- Adding a new sugar format is separate from adding a new template
- Both registries are editable system files that users and Claude can read/modify
