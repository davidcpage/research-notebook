<!-- ========== SECTION: HTML_HEAD ========== -->
<!-- External dependencies: PDF.js, Marked.js, KaTeX, Pyodide, Highlight.js, CodeMirror -->
<!-- All CSS styles included below -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Notebook</title>
    <!-- CodeMirror 6 import map for editor syntax highlighting -->
    <script type="importmap">
    {
        "imports": {
            "style-mod": "https://esm.sh/style-mod@4.1.2",
            "w3c-keyname": "https://esm.sh/w3c-keyname@2.2.8",
            "crelt": "https://esm.sh/crelt@1.0.6",
            "@marijn/find-cluster-break": "https://esm.sh/@marijn/find-cluster-break@1.0.2",
            "@lezer/common": "https://esm.sh/*@lezer/common@1.2.3",
            "@lezer/highlight": "https://esm.sh/*@lezer/highlight@1.2.1",
            "@lezer/lr": "https://esm.sh/*@lezer/lr@1.4.2",
            "@lezer/python": "https://esm.sh/*@lezer/python@1.1.15",
            "@lezer/yaml": "https://esm.sh/*@lezer/yaml@1.0.3",
            "@lezer/css": "https://esm.sh/*@lezer/css@1.1.9",
            "@lezer/markdown": "https://esm.sh/*@lezer/markdown@1.6.1",
            "@lezer/html": "https://esm.sh/*@lezer/html@1.3.12",
            "@lezer/javascript": "https://esm.sh/*@lezer/javascript@1.5.4",
            "@codemirror/autocomplete": "https://esm.sh/*@codemirror/autocomplete@6.18.4",
            "@codemirror/commands": "https://esm.sh/*@codemirror/commands@6.7.1",
            "@codemirror/language": "https://esm.sh/*@codemirror/language@6.10.6",
            "@codemirror/lint": "https://esm.sh/*@codemirror/lint@6.8.4",
            "@codemirror/search": "https://esm.sh/*@codemirror/search@6.5.8",
            "@codemirror/state": "https://esm.sh/*@codemirror/state@6.5.0",
            "@codemirror/view": "https://esm.sh/*@codemirror/view@6.35.0",
            "@codemirror/lang-python": "https://esm.sh/*@codemirror/lang-python@6.1.6",
            "@codemirror/lang-yaml": "https://esm.sh/*@codemirror/lang-yaml@6.1.2",
            "@codemirror/lang-css": "https://esm.sh/*@codemirror/lang-css@6.3.1",
            "@codemirror/lang-markdown": "https://esm.sh/*@codemirror/lang-markdown@6.5.0",
            "@codemirror/lang-html": "https://esm.sh/*@codemirror/lang-html@6.4.11",
            "@codemirror/lang-javascript": "https://esm.sh/*@codemirror/lang-javascript@6.2.4",
            "@codemirror/theme-one-dark": "https://esm.sh/*@codemirror/theme-one-dark@6.1.2",
            "codemirror": "https://esm.sh/*codemirror@6.0.1"
        }
    }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600&family=Source+Sans+3:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
    <!-- Pyodide for Python execution -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.28.2/full/pyodide.js"></script>
    <!-- js-yaml for YAML parsing (template system) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <style>
        :root {
            --bg-primary: #f8f6f3;
            --bg-secondary: #ffffff;
            --bg-accent: #1a1a1a;
            --text-primary: #1a1a1a;
            --text-secondary: #5a5a5a;
            --text-muted: #8a8a8a;
            --border: #e0ddd8;
            --border-dark: #c5c2bd;
            --accent: #c45d3a;
            --accent-hover: #a84d2e;
            --shadow: rgba(26, 26, 26, 0.08);
            --note-bg: #fffef9;
            --note-border: #e8e4d9;
            --link-color: #2563eb;
            --link-hover: #1d4ed8;

            /* Code theme colors */
            --code-bg: #1a3a52;
            --code-text: #e0e6ed;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Source Sans 3', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
        }

        header {
            background: var(--bg-accent);
            color: var(--bg-primary);
            padding: 2.5rem 2rem;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(196, 93, 58, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(196, 93, 58, 0.1) 0%, transparent 40%);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            font-weight: 400;
            letter-spacing: 0.02em;
            margin-bottom: 0.5rem;
        }

        .tagline {
            font-weight: 300;
            color: rgba(248, 246, 243, 0.7);
            font-size: 1rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .toolbar {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem 2rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            border-bottom: 1px solid var(--border);
            background: var(--bg-secondary);
        }

        .toolbar-group {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            letter-spacing: 0.03em;
            padding: 0.75rem 1.5rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-primary);
            border: 1px solid var(--border-dark);
        }

        .btn-secondary:hover {
            background: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .btn-note {
            background: var(--note-bg);
            color: var(--text-primary);
            border: 1px solid var(--note-border);
        }

        .btn-note:hover {
            background: #f5f3e8;
            border-color: var(--accent);
        }

        .btn-code {
            background: #f0f4f0;
            color: var(--text-primary);
            border: 1px solid #c8d4c8;
        }

        .btn-code:hover {
            background: #e4ebe4;
            border-color: #4a7c4a;
        }

        .btn-icon {
            font-size: 1.1rem;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .empty-state {
            text-align: center;
            padding: 6rem 2rem;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.3;
        }

        .empty-state h2 {
            font-family: 'Playfair Display', serif;
            font-weight: 400;
            font-size: 1.5rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .section {
            margin-bottom: 3rem;
            animation: fadeIn 0.4s ease;
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--bg-accent);
            position: relative;
        }

        .section-delete {
            position: absolute;
            left: -0.5rem;
            top: -0.5rem;
            width: 24px;
            height: 24px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 50%;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            color: var(--text-muted);
        }

        .section:hover .section-delete {
            opacity: 1;
        }

        .section-delete:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .section-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.75rem;
            font-weight: 400;
            flex: 1;
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }

        .section-title input {
            font-family: inherit;
            font-size: inherit;
            font-weight: inherit;
            border: none;
            background: transparent;
            outline: none;
            padding: 0.25rem 0;
            border-bottom: 2px solid transparent;
        }

        .section-title input:focus {
            border-bottom-color: var(--accent);
        }

        .section-count {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.875rem;
            font-weight: 400;
            color: var(--text-muted);
            margin-left: 0.75rem;
        }

        .section-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn-small {
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
        }

        .items-grid.collapsed {
            display: none;
        }

        .section-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            color: var(--text-muted);
            transition: transform 0.3s ease;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .section-toggle:hover {
            color: var(--text-primary);
        }

        .section-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .form-group textarea.code-editor {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            min-height: 200px;
            padding: 1rem;
            background: #1e1e1e;
            color: #ffffff;
            border: 1px solid var(--border);
            border-radius: 4px;
            resize: vertical;
            tab-size: 4;
            font-weight: 500;
        }

        .form-group textarea.code-editor::placeholder {
            color: #666;
            font-weight: 300;
            opacity: 0.7;
        }

        .form-group textarea.code-editor:focus {
            outline: none;
            border-color: #4a7c4a;
            background: #1e1e1e;
        }

        /* CodeMirror editor container */
        .codemirror-container {
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
            min-height: 200px;
            max-height: 500px;
        }

        .codemirror-container .cm-editor {
            height: 100%;
            min-height: 200px;
            max-height: 500px;
            font-size: 0.9rem;
        }

        .codemirror-container .cm-scroller {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            line-height: 1.5;
        }

        .code-output {
            min-height: 100px;
            max-height: 400px;
            overflow: auto;
            padding: 1rem;
            background: #fff;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .code-output:empty::before {
            content: 'Output will appear here...';
            color: var(--text-muted);
            font-style: italic;
        }

        .code-output pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .code-output .error {
            color: #dc3545;
        }

        .code-output .stderr {
            color: #856404;
        }

        .code-output img {
            max-width: 100%;
            margin: 0.5rem 0;
        }

        .code-output table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            font-size: 0.8rem;
        }

        .code-output table th,
        .code-output table td {
            border: 1px solid var(--border);
            padding: 0.375rem 0.75rem;
            text-align: left;
        }

        .code-output table th {
            background: var(--bg-primary);
            font-weight: 600;
        }

        .code-output table tr:nth-child(even) {
            background: #fafafa;
        }

        .btn-run {
            background: #28a745;
            color: white;
            border: none;
        }

        .btn-run:hover {
            background: #218838;
        }

        .btn-run:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .pyodide-status {
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .pyodide-status.loading {
            color: #856404;
        }

        .pyodide-status.ready {
            color: #28a745;
        }

        .pyodide-status.error {
            color: #dc3545;
        }

        .spinner-small {
            width: 14px;
            height: 14px;
            border: 2px solid #ccc;
            border-top-color: #856404;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        /* ========== Generic Card Styles (Phase 2 Template System) ========== */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }

        .card:hover {
            box-shadow: 0 8px 30px var(--shadow);
            transform: translateY(-2px);
        }

        .card.highlighted {
            animation: highlightPulse 2s ease-out;
        }

        .card-preview {
            width: 100%;
            height: 180px;
            overflow: hidden;
            position: relative;
        }

        .card-content {
            padding: 1.25rem;
        }

        .card-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0;
            line-height: 1.4;
            color: var(--text-primary);
        }

        .card-title a {
            color: inherit;
            text-decoration: none;
            transition: color 0.15s ease;
        }

        .card-title a:hover {
            color: var(--accent);
        }

        .card-meta {
            padding: 0 1.25rem 0.75rem 1.25rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        /* Card Preview Layouts */
        .preview-placeholder {
            font-size: 3rem;
            color: var(--text-muted);
            opacity: 0.2;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .preview-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center top;
        }

        /* Document preview (zoomed-out page effect) */
        .preview-page {
            width: 100%;
            height: 100%;
            background: #f9f7f3;
            box-shadow: 0 0 8px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
            /* Note: parent .card-preview already has padding for note cards */
        }

        .preview-scaler {
            transform: scale(0.45);
            transform-origin: top left;
            width: 222%;
            padding: 18px 24px;
        }

        .preview-content {
            font-size: 0.925rem;
            color: var(--text-secondary);
            line-height: 1.7;
            overflow: hidden;
        }

        .preview-content h1 { font-family: 'Playfair Display', serif; font-size: 1.5rem; margin-bottom: 0.75rem; color: var(--text-primary); }
        .preview-content h2 { font-family: 'Playfair Display', serif; font-size: 1.25rem; margin: 1.25rem 0 0.5rem; color: var(--text-primary); }
        .preview-content h3 { font-family: 'Playfair Display', serif; font-size: 1.1rem; margin: 1rem 0 0.5rem; color: var(--text-primary); }
        .preview-content p { margin-bottom: 0.875rem; }
        .preview-content ul, .preview-content ol { margin: 0.875rem 0; padding-left: 1.5rem; }
        .preview-content li { margin-bottom: 0.375rem; }
        .preview-content code { font-family: 'Consolas', 'Monaco', monospace; background: #fff; padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.9em; }
        .preview-content pre { background: #fff; padding: 0.75rem; overflow-x: auto; margin: 0.5rem 0; border-radius: 4px; border: 1px solid #e8e4dc; }
        .preview-content pre code { background: none; padding: 0; }
        .preview-content blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; margin: 0.875rem 0; color: var(--text-secondary); font-style: italic; }
        .preview-content table { border-collapse: collapse; margin: 0.5rem 0; width: 100%; font-size: 0.85em; }
        .preview-content table th,
        .preview-content table td { border: 1px solid var(--border); padding: 0.25rem 0.5rem; text-align: left; }
        .preview-content table th { background: var(--bg-primary); font-weight: 600; }
        .preview-content table tr:nth-child(even) { background: #fafafa; }

        .preview-page::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(transparent, #f9f7f3);
            pointer-events: none;
        }

        /* Code preview - dark background */
        .preview-code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.8rem;
            color: var(--code-text);
            line-height: 1.5;
            width: 100%;
            height: 100%;
            overflow: hidden;
            white-space: pre-wrap;
            word-break: break-all;
            margin: 0;
            padding: 1.25rem;
            background: var(--code-bg);
        }

        .preview-code code {
            font-family: inherit;
            font-size: inherit;
            background: transparent !important;
            padding: 0;
            color: var(--code-text);
        }

        .preview-code::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(transparent, var(--code-bg));
            pointer-events: none;
        }

        /* YAML preview - light background for config files */
        .preview-yaml {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.7rem;
            color: #333;
            line-height: 1.4;
            width: 100%;
            height: 100%;
            overflow: hidden;
            white-space: pre-wrap;
            word-break: break-all;
            margin: 0;
            padding: 1rem;
            background: #f8f8f8;
        }

        /* Split pane preview */
        .preview-split {
            display: flex;
            width: 100%;
            height: 100%;
            gap: 1px;
        }

        .preview-split-left {
            padding: 1rem;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--border);
        }

        .preview-split-right {
            padding: 0.75rem;
            overflow: hidden;
            position: relative;
            background: inherit;
        }

        .split-output-content {
            max-width: 100%;
            max-height: 100%;
        }

        .split-output-content img {
            max-height: 150px;
            max-width: 100%;
            display: block;
        }

        .split-code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.4rem;
            color: var(--template-code-text, var(--code-text));
            line-height: 1.2;
            margin: 0;
            overflow: hidden;
            background: transparent;
            padding: 0.5rem;
            height: 100%;
        }

        .split-code code {
            font-family: inherit;
            font-size: inherit;
            background: transparent !important;
            color: inherit;
        }

        /* Fields preview */
        .preview-fields {
            padding: 1rem;
        }

        .preview-field {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
        }

        .preview-field-label {
            font-weight: 500;
            color: var(--text-muted);
        }

        /* Note template: define colors once, used by both card and viewer */
        .card[data-template="note"],
        .modal.viewer[data-template="note"] {
            --template-border: var(--note-border);
            --template-bg: #f0ebe0;
            --template-preview-bg: #e8e3d8;
            --template-title-text: var(--text-primary);
            --template-meta-text: var(--text-muted);
            --template-heading-font: 'Playfair Display', serif;
            --template-body-font: inherit;
        }

        .card[data-template="note"] {
            border-color: var(--template-border);
        }

        .card[data-template="note"] .card-preview {
            background: var(--template-preview-bg);
            padding: 0 15%;
        }

        /* Code template: define colors once, used by both card and viewer.
           Default is light card with dark code areas. Themes can override --template-* variables. */
        .card[data-template="code"],
        .modal.viewer[data-template="code"] {
            --template-border: #d0dcd0;
            --template-bg: white;
            --template-output-bg: #eef4ee;
            --template-code-bg: var(--code-bg);
            --template-code-text: var(--code-text);
            --template-title-text: var(--text-primary);
            --template-meta-text: var(--text-muted);
        }

        .card[data-template="code"] {
            border-color: var(--template-border);
            background: var(--template-bg);
        }

        .card[data-template="code"] .card-preview {
            background: var(--template-code-bg);
        }

        .card[data-template="code"] .card-content {
            background: var(--template-bg);
        }

        .card[data-template="code"] .card-title {
            color: var(--template-title-text);
        }

        .card[data-template="code"] .card-meta {
            background: var(--template-bg);
            color: var(--template-meta-text);
        }

        .card[data-template="code"] .preview-split-left {
            background: var(--template-output-bg);
            border-right: 1px solid var(--template-border);
        }

        .card[data-template="code"] .preview-split-right {
            background: var(--template-code-bg);
        }

        .card[data-template="bookmark"] .card-preview {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--border) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Theme template: define colors once, used by both card and viewer */
        .card[data-template="theme"],
        .modal.viewer[data-template="theme"] {
            --template-border: #d0c8e0;
            --template-bg: #2d2d2d;
            --template-code-bg: #2d2d2d;
            --template-code-text: #c5c8c6;
        }

        .card[data-template="theme"] {
            border-color: var(--template-border);
        }

        .card[data-template="theme"] .card-preview {
            background: var(--template-code-bg);
        }

        .card[data-template="theme"] .preview-code {
            background: var(--template-code-bg);
            color: var(--template-code-text);
            font-size: 0.65rem;
        }

        /* ========== Generic Viewer Styles (Phase 2 Template System) ========== */
        .modal.viewer {
            max-width: 900px;
            min-height: 60vh;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 90%;
            box-sizing: border-box;
        }

        .modal.viewer * {
            box-sizing: border-box;
        }

        .modal.viewer .modal-header {
            padding: 1.25rem 1.25rem 1rem;
            background: var(--bg-secondary);
            border-bottom: none;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .modal.viewer .modal-header h2 {
            font-family: 'Playfair Display', serif;
            font-size: 1.25rem;
            font-weight: 600;
            flex: 1;
            margin: 0;
        }

        .viewer-content {
            padding: 1.25rem;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Remove padding when content has full-width layouts */
        .viewer-content:has(.viewer-split-pane),
        .viewer-content:has(.viewer-code-only) {
            padding: 0;
        }

        .viewer-backlinks {
            padding: 0 1.25rem;
        }

        .viewer-footer {
            padding: 1rem 1.25rem;
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid var(--border);
        }

        .viewer-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .viewer-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Viewer content layouts */
        .viewer-markdown {
            line-height: 1.7;
            font-size: 0.925rem;
            color: var(--text-secondary);
        }

        .viewer-markdown h1 { font-family: 'Playfair Display', serif; font-size: 1.5rem; margin-bottom: 0.75rem; color: var(--text-primary); }
        .viewer-markdown h2 { font-family: 'Playfair Display', serif; font-size: 1.25rem; margin: 1.25rem 0 0.5rem; color: var(--text-primary); }
        .viewer-markdown h3 { font-family: 'Playfair Display', serif; font-size: 1.1rem; margin: 1rem 0 0.5rem; color: var(--text-primary); }
        .viewer-markdown p { margin-bottom: 0.875rem; }
        .viewer-markdown ul, .viewer-markdown ol { margin: 0.875rem 0; padding-left: 1.5rem; }
        .viewer-markdown li { margin-bottom: 0.375rem; }
        .viewer-markdown code { font-family: 'Consolas', 'Monaco', monospace; background: #fff; padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.9em; }
        .viewer-markdown pre { background: #fff; padding: 1rem; overflow-x: auto; margin: 0.875rem 0; border-radius: 4px; max-width: 100%; border: 1px solid #e8e4dc; }
        .viewer-markdown pre code { background: none; padding: 0; }
        /* Override highlight.js dark theme for markdown content (use light background) */
        .preview-content .hljs,
        .viewer-markdown .hljs {
            background: transparent !important;
            color: var(--text-primary) !important;
        }
        .viewer-markdown blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; margin: 0.875rem 0; color: var(--text-secondary); font-style: italic; }
        .viewer-markdown a { color: var(--accent); text-decoration: none; }
        .viewer-markdown a:hover { text-decoration: underline; }
        .viewer-markdown img { max-width: 100%; height: auto; border-radius: 4px; margin: 0.5rem 0; }
        .viewer-markdown table { border-collapse: collapse; margin: 0.875rem 0; width: 100%; font-size: 0.9em; }
        .viewer-markdown table th,
        .viewer-markdown table td { border: 1px solid var(--border); padding: 0.5rem 0.75rem; text-align: left; }
        .viewer-markdown table th { background: var(--bg-primary); font-weight: 600; }
        .viewer-markdown table tr:nth-child(even) { background: #fafafa; }

        .viewer-text {
            margin: 0;
            white-space: pre-wrap;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .viewer-yaml {
            margin: 0;
            padding: 1.5rem;
            white-space: pre-wrap;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            background: #f8f8f8;
            border-radius: 4px;
        }

        .viewer-empty {
            padding: 2rem;
            text-align: center;
            color: var(--text-muted);
        }

        .viewer-loading {
            padding: 2rem;
            text-align: center;
            color: var(--text-muted);
        }

        .viewer-error {
            padding: 2rem;
        }

        /* Image viewer layout */
        .viewer-image-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .viewer-thumbnail {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--border) 100%);
            border-radius: 8px;
        }

        .viewer-thumbnail img {
            max-width: 80%;
            max-height: 300px;
            object-fit: contain;
            border-radius: 4px;
        }

        .viewer-thumbnail .placeholder {
            font-size: 4rem;
            color: var(--text-muted);
            opacity: 0.3;
        }

        .viewer-url {
            font-size: 0.8rem;
            color: var(--text-muted);
            padding: 0.5rem 0.75rem;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 1px solid var(--border);
            word-break: break-all;
        }

        .viewer-url a {
            color: var(--accent);
            text-decoration: none;
        }

        .viewer-url a:hover {
            text-decoration: underline;
        }

        .viewer-description {
            line-height: 1.7;
            color: var(--text-secondary);
            font-size: 0.925rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        .viewer-description p { margin: 0 0 0.75rem 0; }
        .viewer-description p:last-child { margin-bottom: 0; }
        .viewer-description ul, .viewer-description ol { margin: 0.75rem 0; padding-left: 1.75rem; }
        .viewer-description li { margin-bottom: 0.375rem; }
        .viewer-description li:last-child { margin-bottom: 0; }
        .viewer-description code { font-family: 'Consolas', 'Monaco', monospace; background: var(--bg-secondary); padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.9em; }
        .viewer-description blockquote { border-left: 3px solid var(--accent); padding-left: 1rem; margin: 0.75rem 0; color: var(--text-muted); font-style: italic; }
        .viewer-description a { color: var(--accent); text-decoration: none; }
        .viewer-description a:hover { text-decoration: underline; }
        .viewer-description table { border-collapse: collapse; margin: 0.75rem 0; width: 100%; font-size: 0.9em; }
        .viewer-description table th,
        .viewer-description table td { border: 1px solid var(--border); padding: 0.5rem 0.75rem; text-align: left; }
        .viewer-description table th { background: var(--bg-secondary); font-weight: 600; }
        .viewer-description table tr:nth-child(even) { background: var(--bg-secondary); }

        /* Split pane viewer layout */
        .viewer-split-pane {
            display: flex;
            min-height: 300px;
            width: 100%;
        }

        .viewer-split-left {
            flex: 0 0 60%;
            padding: 2rem;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--border);
        }

        .viewer-split-right {
            flex: 1;
            padding: 1.5rem;
            overflow: auto;
            background: var(--code-bg);
        }

        .viewer-split-right pre {
            margin: 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--code-text);
        }

        .viewer-split-right code {
            background: transparent !important;
            color: var(--code-text);
            font-family: inherit;
        }

        .viewer-output-content {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .viewer-output-content img {
            max-width: 100%;
            max-height: 300px;
            display: block;
            border-radius: 4px;
        }

        /* Code-only viewer - dark background */
        .viewer-code-only {
            padding: 2rem;
            background: var(--code-bg);
        }

        .viewer-code-only pre {
            margin: 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--code-text);
        }

        .viewer-code-only code {
            background: transparent !important;
            color: var(--code-text);
        }

        /* Sections viewer layout */
        .viewer-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        .viewer-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .viewer-section-title {
            font-family: 'Playfair Display', serif;
            font-size: 1rem;
            font-weight: 600;
            margin: 0 0 0.75rem 0;
            color: var(--text-primary);
        }

        .viewer-section-content {
            line-height: 1.6;
            color: var(--text-secondary);
        }

        /* Template-specific viewer styles */
        .modal.viewer[data-template="note"] {
            background: var(--template-bg);
            border: 1px solid var(--template-border);
        }

        .modal.viewer[data-template="note"] .modal-header h2 {
            font-family: var(--template-heading-font);
            color: var(--template-title-text);
        }

        .modal.viewer[data-template="note"] .viewer-meta {
            color: var(--template-meta-text);
        }

        .modal.viewer[data-template="code"] {
            background: var(--template-bg);
            border: 1px solid var(--template-border);
        }

        .modal.viewer[data-template="code"] .modal-header {
            background: var(--template-bg);
        }

        .modal.viewer[data-template="code"] .modal-header h2 {
            color: var(--template-title-text);
        }

        .modal.viewer[data-template="code"] .viewer-split-left {
            background: var(--template-output-bg);
        }

        .modal.viewer[data-template="code"] .viewer-split-right {
            background: var(--template-code-bg);
        }

        .modal.viewer[data-template="code"] .viewer-footer {
            background: var(--template-bg);
            border-top-color: var(--template-border);
        }

        .modal.viewer[data-template="code"] .viewer-meta {
            color: var(--template-meta-text);
        }

        .modal.viewer[data-template="code"] .viewer-actions .btn-secondary {
            color: var(--template-title-text);
            border-color: var(--template-border);
        }

        .modal.viewer[data-template="code"] .viewer-actions .btn-secondary:hover {
            background: var(--template-output-bg);
            border-color: var(--template-title-text);
        }

        .modal.viewer[data-template="bookmark"] {
            background: var(--bg-secondary);
        }

        .modal.viewer[data-template="theme"] {
            background: var(--template-bg);
            border: 1px solid var(--template-border);
        }

        .modal.viewer[data-template="theme"] .viewer-content {
            background: var(--template-code-bg);
            color: var(--template-code-text);
        }

        .modal.viewer[data-template="theme"] .viewer-content pre {
            color: var(--template-code-text);
        }

        /* Override highlight.js in generic viewer */
        .viewer-split-right .hljs,
        .viewer-code-only .hljs {
            background: transparent !important;
            color: var(--code-text) !important;
        }

        /* Internal Links */
        .internal-link {
            color: var(--link-color);
            text-decoration: none;
            border-bottom: 1px dashed var(--link-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .internal-link:hover {
            color: var(--link-hover);
            border-bottom-style: solid;
        }

        .internal-link.broken {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        /* Backlinks */
        .backlinks {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .backlinks-title {
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .backlinks-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .backlink-item {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .backlink-item:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(26, 26, 26, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
            overflow: hidden;
        }

        .modal {
            background: var(--bg-secondary);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-large {
            max-width: 800px;
        }

        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h2 {
            font-family: 'Playfair Display', serif;
            font-weight: 400;
            font-size: 1.5rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 1.5rem;
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-group label {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.75rem 1rem;
            font-family: 'Source Sans 3', sans-serif;
            font-size: 1rem;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            transition: all 0.2s;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent);
            background: var(--bg-secondary);
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-group textarea.markdown-editor {
            min-height: 300px;
            font-family: 'Source Sans 3', sans-serif;
            line-height: 1.6;
        }

        .form-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        /* List editor styles */
        .list-editor {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .list-editor-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .list-editor-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .list-editor-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .list-editor-input[readonly] {
            background: var(--bg-secondary);
            cursor: default;
        }

        .list-editor-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .list-editor-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--text-muted);
            transition: all 0.15s;
        }

        .list-editor-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .list-editor-btn-delete:hover {
            background: #fee;
            border-color: #c00;
            color: #c00;
        }

        .list-editor-add {
            align-self: flex-start;
            margin-top: 0.5rem;
            padding: 0.4rem 0.8rem;
            border: 1px dashed var(--border);
            border-radius: 4px;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.15s;
        }

        .list-editor-add:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-secondary);
        }

        /* Records editor styles */
        .records-editor {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .records-editor-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            transition: opacity 0.15s;
        }

        .records-editor-item.is-hidden {
            opacity: 0.5;
        }

        .records-editor-fields {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .records-editor-input {
            flex: 1;
            padding: 0.4rem 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.9rem;
            background: white;
        }

        .records-editor-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .records-editor-input[readonly] {
            background: var(--bg-primary);
            cursor: default;
        }

        .records-editor-toggle {
            width: 32px;
            height: 32px;
            padding: 0;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.15s;
        }

        .records-editor-toggle:hover {
            background: var(--bg-primary);
            border-color: var(--accent);
        }

        .records-editor-toggle.is-hidden {
            opacity: 0.6;
        }

        .records-editor-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .records-editor-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--text-muted);
            transition: all 0.15s;
        }

        .records-editor-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .records-editor-btn-delete:hover {
            background: #fee;
            border-color: #c00;
            color: #c00;
        }

        .records-editor-add {
            align-self: flex-start;
            margin-top: 0.5rem;
            padding: 0.4rem 0.8rem;
            border: 1px dashed var(--border);
            border-radius: 4px;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.15s;
        }

        .records-editor-add:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-secondary);
        }

        .thumbnail-upload {
            width: 100%;
            height: 180px;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--border) 100%);
            border: 2px dashed var(--border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
        }

        .thumbnail-upload:hover {
            border-color: var(--accent);
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--border) 100%);
        }

        .thumbnail-upload.drag-over {
            border-color: var(--accent);
            border-style: solid;
            background: var(--bg-secondary);
            transform: scale(1.02);
        }

        .thumbnail-upload img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center top;
        }

        .thumbnail-placeholder {
            text-align: center;
            pointer-events: none;
        }

        .thumbnail-icon {
            font-size: 3rem;
            opacity: 0.3;
            display: block;
            margin-bottom: 0.5rem;
        }

        .thumbnail-hint {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin: 0;
            line-height: 1.5;
        }

        .thumbnail-upload.has-image .thumbnail-placeholder {
            display: none;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        /* Generic editor modal footer layout */
        #editorModal .modal-footer {
            justify-content: space-between;
        }
        .editor-actions-left {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .editor-actions-right {
            display: flex;
            gap: 0.75rem;
        }
        .editor-status {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* Constrain thumbnail preview in generic editor */
        #editorModal .thumbnail-upload {
            max-width: 400px;
        }

        /* Field width variants for generic editor */
        .form-field-half {
            display: inline-block;
            width: calc(50% - 0.5rem);
            vertical-align: top;
        }
        .form-field-half:nth-child(odd) {
            margin-right: 0.5rem;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--bg-accent);
            color: var(--bg-primary);
            padding: 1rem 1.5rem;
            font-size: 0.875rem;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .toast.active {
            transform: translateY(0);
            opacity: 1;
        }

        /* Tab switcher for note editor */
        .editor-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 1rem;
        }

        .editor-tab {
            padding: 0.5rem 1rem;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .editor-tab:hover {
            color: var(--text-primary);
        }

        .editor-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .editor-preview {
            display: none;
            padding: 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.7;
        }

        .editor-preview.active {
            display: block;
        }

        .editor-preview h1, .editor-preview h2, .editor-preview h3 {
            font-family: 'Playfair Display', serif;
        }

        .editor-preview p {
            margin-bottom: 1rem;
        }

        .editor-preview .katex-display {
            margin: 1rem 0;
        }

        @media (max-width: 768px) {
            header {
                padding: 1.5rem 1rem;
            }

            h1 {
                font-size: 1.75rem;
            }

            .toolbar {
                padding: 1rem;
            }

            main {
                padding: 1rem;
            }

            .items-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Print styles for exporting viewer content */
        @media print {
            /* Hide everything except the viewer modal */
            body > *:not(.modal-overlay) {
                display: none !important;
            }

            /* Reset modal overlay to static positioning for print flow */
            .modal-overlay {
                position: static !important;
                background: none !important;
                display: block !important;
                opacity: 1 !important;
                visibility: visible !important;
                overflow: visible !important;
            }

            .modal-overlay:not(.active) {
                display: none !important;
            }

            /* Reset modal to static, full-width, auto-height for proper pagination */
            .modal.viewer {
                position: static !important;
                transform: none !important;
                width: 100% !important;
                max-width: none !important;
                max-height: none !important;
                min-height: auto !important;
                height: auto !important;
                overflow: visible !important;
                box-shadow: none !important;
                display: block !important;
            }

            .viewer-content {
                overflow: visible !important;
                height: auto !important;
                max-height: none !important;
            }

            /* Ensure text wraps properly within page margins */
            .viewer-markdown,
            .viewer-text,
            .viewer-content {
                word-wrap: break-word !important;
                overflow-wrap: break-word !important;
                max-width: 100% !important;
            }

            /* Pre/code blocks: preserve formatting (no wrapping for ASCII diagrams) */
            .viewer-markdown pre,
            .viewer-content pre,
            pre {
                white-space: pre !important;
                overflow-x: visible !important;
            }

            /* Tables should not overflow page */
            .viewer-markdown table,
            .viewer-content table {
                max-width: 100% !important;
                table-layout: fixed !important;
            }

            .viewer-markdown td,
            .viewer-markdown th,
            .viewer-content td,
            .viewer-content th {
                word-wrap: break-word !important;
                overflow-wrap: break-word !important;
            }

            /* Hide UI elements not needed in print */
            .modal-close,
            .viewer-footer,
            .viewer-backlinks {
                display: none !important;
            }

            /* Remove modal frame/border */
            .modal.viewer {
                border: none !important;
                border-radius: 0 !important;
            }

            .modal-header {
                border-bottom: none !important;
            }

            /* Ensure content flows across pages */
            .viewer-content,
            .viewer-content * {
                break-inside: auto;
            }

            /* Avoid breaking inside these elements */
            pre, code, img, .katex-display {
                break-inside: avoid;
            }

            /* Tables need extra specificity and display reset for break-inside to work */
            table, .viewer-content table, .markdown-content table {
                break-inside: avoid !important;
                page-break-inside: avoid !important;  /* Legacy property for older browsers */
                display: table !important;  /* Ensure table display mode */
            }

            thead {
                display: table-header-group;  /* Repeat headers on each page if table does break */
            }

            tr {
                break-inside: avoid;
                page-break-inside: avoid;
            }

            /* Remove parchment/colored backgrounds for cleaner PDF */
            html, body,
            .modal-overlay,
            .modal.viewer,
            .modal.viewer[data-template="note"],
            .modal.viewer[data-template="code"],
            .modal.viewer[data-template="bookmark"],
            .viewer-content,
            .markdown-content {
                background: white !important;
            }

            /* Page setup: reduced margins for wider content area */
            @page {
                margin: 0.5in;
            }

            /* Slightly smaller font for print to fit more content */
            .viewer-markdown,
            .viewer-content {
                font-size: 0.85rem !important;
            }

            .viewer-markdown pre,
            .viewer-content pre,
            pre {
                font-size: 0.75rem !important;
            }

            /* Ensure backgrounds print (for code blocks) */
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
        }
    </style>
</head>
<!-- ========== SECTION: HTML_BODY_AND_MODALS ========== -->
<!-- Header, toolbar, main content area, and all modal templates -->
<body>
    <header>
        <div class="header-content">
            <h1 id="headerTitle">Research Notebook</h1>
            <p class="tagline" id="headerSubtitle">Bookmarks, notes, and connections</p>
        </div>
    </header>

    <div class="toolbar">
        <div class="toolbar-group">
            <button class="btn btn-primary" onclick="openSectionModal()">
                <span class="btn-icon">+</span> New Section
            </button>
        </div>
        <div class="toolbar-group" style="margin-left: auto;">
            <button class="btn btn-secondary" onclick="openSettingsEditor()" title="Settings" style="color: var(--text-muted);">
                <span class="btn-icon"></span>
            </button>
        </div>
    </div>

    <main id="content">
        <div class="empty-state">
            <div class="empty-state-icon"></div>
            <h2>Your research notebook awaits</h2>
            <p>Create a section to start organizing your bookmarks and notes</p>
        </div>
    </main>

    <!-- Section Modal -->
    <div class="modal-overlay" id="sectionModal">
        <div class="modal">
            <div class="modal-header">
                <h2>New Section</h2>
                <button class="modal-close" onclick="closeSectionModal()"></button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="sectionName">Section Name</label>
                    <input type="text" id="sectionName" placeholder="e.g., Machine Learning Papers">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSectionModal()">Cancel</button>
                <button class="btn btn-primary" onclick="createSection()">Create Section</button>
            </div>
        </div>
    </div>

    <!-- Generic Viewer Modal (Phase 2 Template System) -->
    <div class="modal-overlay" id="viewerModal">
        <div class="modal viewer" data-template="">
            <div class="modal-header">
                <h2 id="viewerTitle">Title</h2>
                <button class="modal-close" onclick="closeViewer()"></button>
            </div>
            <div class="viewer-content" id="viewerContent"></div>
            <div id="viewerBacklinks" class="viewer-backlinks"></div>
            <div class="viewer-footer">
                <span id="viewerMeta" class="viewer-meta"></span>
                <div id="viewerActions" class="viewer-actions"></div>
            </div>
        </div>
    </div>

    <!-- Generic Editor Modal (Phase 3 Template System) -->
    <div class="modal-overlay" id="editorModal">
        <div class="modal modal-large" data-template="">
            <div class="modal-header">
                <h2 id="editorTitle">New Card</h2>
                <button class="modal-close" onclick="closeEditor()"></button>
            </div>
            <div class="modal-body" id="editorBody">
                <!-- Section selector (injected first) -->
                <!-- Dynamic fields from template.editor.fields -->
            </div>
            <div id="editorOutput" class="form-group" style="display: none;">
                <label>Output</label>
                <div class="code-output" id="editorCodeOutput"></div>
            </div>
            <div class="modal-footer">
                <div id="editorActions" class="editor-actions-left"></div>
                <div class="editor-actions-right">
                    <button class="btn btn-secondary" onclick="closeEditor()">Cancel</button>
                    <button class="btn btn-primary" id="editorSubmitBtn" onclick="saveEditor()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal -->
    <div class="modal-overlay" id="onboardingModal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h2>Welcome to Research Notebook</h2>
            </div>
            <div class="modal-body" style="text-align: center; padding: 30px 20px;">
                <div style="font-size: 4rem; margin-bottom: 20px;"></div>
                <p style="color: var(--text-secondary); font-size: 1.1rem; margin-bottom: 20px; line-height: 1.6;">
                    Your notebook is stored as files on your computer, making it easy to use with Claude Code and track changes with git.
                </p>
                <p style="color: var(--text-muted); font-size: 0.95rem; margin-bottom: 30px;">
                    Choose a folder to store your notebook. You can select an empty folder to start fresh, or pick a folder with an existing notebook.
                </p>
                <button class="btn btn-primary" onclick="setupNotebookFolder()" style="padding: 12px 32px; font-size: 1.1rem;">
                     Choose Notebook Folder
                </button>
                <div id="onboardingUnsupported" style="display: none; margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px;">
                    <p style="color: #856404; margin: 0; font-size: 0.9rem;">
                         File System Access is not supported in this browser.<br>
                        Please use <strong>Chrome</strong> or <strong>Edge</strong> for the full experience.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // ========== SECTION: STATE_AND_CONFIG ==========
        // Global data structure, state variables, editing trackers, Pyodide state, marked config

        // Data structure
        let data = {
            title: 'Research Notebook',
            subtitle: 'Bookmarks, notes, and connections',
            sections: [],
            systemNotes: [],  // Markdown files at notebook root (README.md, CLAUDE.md, etc.)
            // Notes are stored in sections alongside bookmarks
            // Each item has a 'type' field: 'bookmark', 'note', or 'code'
        };

        // Track collapsed sections (persisted to sessionStorage across refresh)
        let collapsedSections = new Set();

        // Save collapsed sections to sessionStorage
        function saveCollapsedSections() {
            sessionStorage.setItem('collapsedSections', JSON.stringify([...collapsedSections]));
        }

        // Restore collapsed sections from sessionStorage
        function restoreCollapsedSections() {
            const saved = sessionStorage.getItem('collapsedSections');
            if (saved) {
                try {
                    collapsedSections = new Set(JSON.parse(saved));
                } catch (e) {
                    console.warn('Failed to restore collapsed sections:', e);
                }
            }
        }

        // Pyodide state
        let pyodide = null;
        let pyodideLoading = false;
        let pyodideReady = false;

        // Filesystem state
        let notebookDirHandle = null;  // FileSystemDirectoryHandle for linked folder
        let filesystemLinked = false;   // Whether filesystem mode is active
        const IDB_DIR_HANDLE_KEY = 'notebookDirHandle';  // IndexedDB key for persisting handle

        // FileSystemObserver state (Phase 2: Change Detection)
        let filesystemObserver = null;  // FileSystemObserver instance for watching changes
        let isReloadingFromFilesystem = false;  // Flag to prevent observer triggering during reload

        // Configure marked for safe rendering
        marked.setOptions({
            breaks: true,
            gfm: true
        });

        // ========== SECTION: TEMPLATE_SYSTEM ==========
        // Template and extension registry infrastructure for unified card handling
        // Phase 1 (Loading): loadExtensionRegistry, loadTemplates, getDefaultExtensionRegistry,
        //            getDefaultTemplates, getTemplateFileContent, getExtensionRegistryContent,
        //            ensureTemplateFiles, parsers, serializers, loadCard, serializeCard
        // Phase 2 (Rendering): renderCard, renderCardPreview, renderCardTitle, renderCardMeta,
        //            renderDocumentPreview, renderImagePreview, renderSplitPanePreview, renderFieldsPreview,
        //            openViewer, renderViewerContent, renderViewerDocument, renderViewerImage,
        //            renderViewerSplitPane, renderViewerSections, renderViewerActions,
        //            closeViewer, editViewerCard, deleteViewerCard, runViewerCode,
        //            loadThemeCss, injectTemplateStyles

        // Extension registry - maps file extensions to parsing behavior
        // Loaded from extensions.yaml or uses defaults
        let extensionRegistry = null;

        // Template registry - maps template names to their definitions
        // Loaded from *.template.yaml files or uses defaults
        let templateRegistry = {};

        // Get the default extension registry (hardcoded fallback)
        function getDefaultExtensionRegistry() {
            return {
                '.md': {
                    parser: 'yaml-frontmatter',
                    defaultTemplate: 'note',
                    bodyField: 'content'
                },
                '.code.py': {
                    parser: 'comment-frontmatter',
                    defaultTemplate: 'code',
                    bodyField: 'code',
                    companionFiles: [
                        { suffix: '.output.html', field: 'output' }
                    ]
                },
                '.bookmark.json': {
                    parser: 'json',
                    defaultTemplate: 'bookmark'
                },
                '.card.yaml': {
                    parser: 'yaml',
                    defaultTemplate: null  // Must specify template: in file
                }
            };
        }

        // Get the default templates (hardcoded fallback)
        function getDefaultTemplates() {
            return {
                note: {
                    name: 'note',
                    description: 'Markdown note with full formatting support',
                    schema: {
                        title: { type: 'text', required: true },
                        content: { type: 'markdown', required: true },
                        created: { type: 'datetime' },
                        modified: { type: 'datetime' }
                    },
                    card: {
                        layout: 'document',
                        preview_field: 'content',
                        placeholder: ''
                    },
                    viewer: {
                        layout: 'document',
                        content_field: 'content'
                    },
                    editor: {
                        fields: [
                            { field: 'title', label: 'Title' },
                            { field: 'content', label: 'Content', multiline: true, rows: 20, preview: true }
                        ]
                    },
                    style: {
                        variables: {
                            '--preview-bg': '#f0ebe0'
                        }
                    },
                    ui: {
                        button_label: 'Note',
                        icon: '',
                        sort_order: 1
                    }
                },
                code: {
                    name: 'code',
                    description: 'Executable Python code with output',
                    schema: {
                        title: { type: 'text', required: true },
                        code: { type: 'code', language: 'python', required: true },
                        output: { type: 'html' },
                        showOutput: { type: 'boolean', default: true }
                    },
                    card: {
                        layout: 'split-pane',
                        slots: {
                            left: { field: 'output', width: '60%' },
                            right: { field: 'code', width: '40%' }
                        },
                        fallback_layout: 'document',
                        fallback_field: 'code',
                        placeholder: ''
                    },
                    viewer: {
                        layout: 'split-pane',
                        slots: {
                            left: { field: 'output', width: '60%' },
                            right: { field: 'code', width: '40%' }
                        }
                    },
                    editor: {
                        fields: [
                            { field: 'title', label: 'Title' },
                            { field: 'code', label: 'Code', multiline: true, rows: 20, monospace: true }
                        ],
                        actions: [
                            { label: 'Run', action: 'execute', icon: '' }
                        ]
                    },
                    style: {
                        variables: {
                            '--card-bg': '#f8faf8'
                        }
                    },
                    ui: {
                        button_label: 'Code',
                        icon: '',
                        sort_order: 2
                    }
                },
                bookmark: {
                    name: 'bookmark',
                    description: 'Web bookmark with thumbnail and description',
                    schema: {
                        title: { type: 'text', required: true },
                        url: { type: 'url', required: true },
                        description: { type: 'markdown' },
                        thumbnail: { type: 'thumbnail', auto_generate: true },
                        favicon: { type: 'url' },
                        created: { type: 'datetime' },
                        modified: { type: 'datetime' }
                    },
                    card: {
                        layout: 'image',
                        preview_field: 'thumbnail',
                        placeholder: '',
                        title_link_field: 'url'
                    },
                    viewer: {
                        layout: 'image',
                        image_field: 'thumbnail',
                        content_field: 'description'
                    },
                    editor: {
                        fields: [
                            { field: 'thumbnail', label: 'Thumbnail (optional)', widget: 'thumbnail-upload' },
                            { field: 'url', label: 'URL', auto_fetch: true },
                            { field: 'title', label: 'Title (optional)' },
                            { field: 'description', label: 'Description (optional)', multiline: true, rows: 4 }
                        ]
                    },
                    style: {
                        variables: {
                            '--preview-bg': 'linear-gradient(135deg, #f8f6f3 0%, #e8e4df 100%)'
                        }
                    },
                    ui: {
                        button_label: 'Bookmark',
                        icon: '',
                        sort_order: 3
                    }
                },
                settings: {
                    name: 'settings',
                    description: 'Notebook configuration',
                    schema: {
                        notebook_title: { type: 'text', required: true },
                        notebook_subtitle: { type: 'text' },
                        sections: {
                            type: 'records',
                            allowDelete: false,
                            allowAdd: false,
                            schema: {
                                name: { type: 'text', readOnly: true },
                                visible: { type: 'boolean', default: true, label: 'Visible' }
                            }
                        },
                        extensions: { type: 'yaml' },
                        theme: { type: 'text' }
                    },
                    card: {
                        layout: 'yaml',
                        placeholder: ''
                    },
                    viewer: {
                        layout: 'yaml'
                    },
                    editor: {
                        fields: [
                            { field: 'notebook_title', label: 'Notebook Title' },
                            { field: 'notebook_subtitle', label: 'Subtitle' },
                            { field: 'sections', label: 'Sections' },
                            { field: 'extensions', label: 'Extension Registry', multiline: true, rows: 20, monospace: true },
                            { field: 'theme', label: 'Theme CSS file (optional)' }
                        ]
                    },
                    style: {
                        variables: {
                            '--preview-bg': '#f5f5f5'
                        }
                    },
                    ui: {
                        button_label: 'Settings',
                        icon: '',
                        show_create_button: false,
                        sort_order: 99
                    }
                },
                template: {
                    name: 'template',
                    description: 'Template definition file',
                    schema: {
                        name: { type: 'text', required: true },
                        description: { type: 'text' },
                        schema: { type: 'yaml' },
                        card: { type: 'yaml' },
                        viewer: { type: 'yaml' },
                        editor: { type: 'yaml' },
                        style: { type: 'yaml' },
                        ui: { type: 'yaml' }
                    },
                    card: {
                        layout: 'yaml',
                        placeholder: ''
                    },
                    viewer: {
                        layout: 'yaml'
                    },
                    editor: {
                        fields: [
                            { field: 'name', label: 'Template Name' },
                            { field: 'description', label: 'Description' },
                            { field: 'schema', label: 'Schema', rows: 10 },
                            { field: 'card', label: 'Card Layout', rows: 6 },
                            { field: 'viewer', label: 'Viewer Layout', rows: 4 },
                            { field: 'editor', label: 'Editor Config', rows: 6 },
                            { field: 'style', label: 'Style', rows: 4 },
                            { field: 'ui', label: 'UI Config', rows: 4 }
                        ]
                    },
                    style: {
                        variables: {
                            '--preview-bg': '#f0f4f8'
                        }
                    },
                    ui: {
                        button_label: 'Template',
                        icon: '',
                        show_create_button: false,
                        sort_order: 98
                    }
                },
                theme: {
                    name: 'theme',
                    description: 'Custom CSS theme for notebook styling',
                    schema: {
                        content: { type: 'code', language: 'css', required: true }
                    },
                    card: {
                        layout: 'document',
                        preview_field: 'content',
                        placeholder: ''
                    },
                    viewer: {
                        layout: 'document',
                        content_field: 'content'
                    },
                    editor: {
                        fields: [
                            { field: 'content', label: 'Theme CSS', multiline: true, rows: 30, monospace: true, language: 'css' }
                        ]
                    },
                    style: {
                        variables: {
                            '--preview-bg': '#2d2d2d'
                        }
                    },
                    ui: {
                        button_label: 'Theme',
                        icon: '',
                        show_create_button: false,
                        sort_order: 97
                    }
                }
            };
        }

        // Generate YAML content for a template file
        function getTemplateFileContent(templateName) {
            const templates = getDefaultTemplates();
            const template = templates[templateName];
            if (!template) return null;

            // Convert template object to YAML string
            return jsyaml.dump(template, {
                indent: 2,
                lineWidth: -1,  // No line wrapping
                quotingType: '"',
                forceQuotes: false
            });
        }

        // Generate YAML content for extensions.yaml (legacy, for migration)
        function getExtensionRegistryContent() {
            const registry = getDefaultExtensionRegistry();
            return jsyaml.dump({ extensions: registry }, {
                indent: 2,
                lineWidth: -1,
                quotingType: '"',
                forceQuotes: false
            });
        }

        // Generate default theme.css content (minimal starter for new notebooks)
        function getDefaultThemeContent() {
            return `/*
 * Research Notebook Theme
 * =======================
 * Customize your notebook's appearance by uncommenting and modifying styles below.
 * This file loads after the app's built-in styles, so your changes take precedence.
 *
 * For a complete reference of all customizable elements, see:
 * https://github.com/anthropics/research-notebook/blob/main/theme.css
 */


/* ==========================================================================
   GLOBAL COLOR VARIABLES
   ==========================================================================
   Uncomment and modify these to change colors throughout the entire app.
*/

/*
:root {
    /* Backgrounds */
    --bg-primary: #f8f6f3;        /* Main page background */
    --bg-secondary: #ffffff;      /* Card and modal backgrounds */
    --bg-accent: #1a1a1a;         /* Header background */

    /* Text colors */
    --text-primary: #1a1a1a;      /* Main body text */
    --text-secondary: #5a5a5a;    /* Secondary text */
    --text-muted: #8a8a8a;        /* Muted text, metadata */

    /* Borders */
    --border: #e0ddd8;            /* Standard borders */
    --border-dark: #c5c2bd;       /* Darker borders (buttons) */

    /* Accent color (buttons, links, highlights) */
    --accent: #c45d3a;            /* Primary accent (terracotta) */
    --accent-hover: #a84d2e;      /* Accent hover state */

    /* Code blocks */
    --code-bg: #1a3a52;           /* Code background (dark teal) */
    --code-text: #e0e6ed;         /* Code text color */

    /* Internal wiki links */
    --link-color: #2563eb;        /* Link color (blue) */
    --link-hover: #1d4ed8;        /* Link hover color */
}
*/


/* ==========================================================================
   TEMPLATE STYLING
   ==========================================================================
   Style specific card types using template variables.
   The same selector styles BOTH the card AND its viewer for consistency.

   Available variables:
   --template-border, --template-bg, --template-preview-bg,
   --template-title-text, --template-meta-text, --template-heading-font,
   --template-code-bg, --template-code-text, --template-output-bg
*/

/* Example: Customize note cards */
/*
.card[data-template="note"],
.modal.viewer[data-template="note"] {
    --template-border: #d9d0be;
    --template-bg: #f6f0e2;
    --template-heading-font: Georgia, serif;
}
*/


/* ==========================================================================
   YOUR CUSTOMIZATIONS
   ==========================================================================
   Add your custom styles below.
*/

`;
        }

        // Generate default settings.yaml content
        function getDefaultSettingsContent(title = 'Research Notebook', subtitle = 'Bookmarks, notes, and connections', sections = ['research']) {
            const registry = getDefaultExtensionRegistry();
            const settings = {
                notebook_title: title,
                notebook_subtitle: subtitle,
                sections: sections,
                extensions: registry,
                theme: null
            };
            return jsyaml.dump(settings, {
                indent: 2,
                lineWidth: -1,
                quotingType: '"',
                forceQuotes: false
            });
        }

        // Global settings object (loaded from settings.yaml)
        let notebookSettings = null;

        // Load settings from settings.yaml (with migration from legacy format)
        async function loadSettings(dirHandle) {
            if (!dirHandle) {
                notebookSettings = {
                    notebook_title: 'Research Notebook',
                    notebook_subtitle: 'Bookmarks, notes, and connections',
                    sections: [{ name: 'research', visible: true }],
                    extensions: getDefaultExtensionRegistry(),
                    theme: null
                };
                return notebookSettings;
            }

            // Try to load settings.yaml first (new format)
            try {
                const settingsFile = await dirHandle.getFileHandle('settings.yaml');
                const file = await settingsFile.getFile();
                const content = await file.text();
                const parsed = jsyaml.load(content);
                notebookSettings = {
                    notebook_title: parsed.notebook_title || 'Research Notebook',
                    notebook_subtitle: parsed.notebook_subtitle || 'Bookmarks, notes, and connections',
                    sections: normalizeSectionsFormat(parsed.sections || []),
                    extensions: parsed.extensions || getDefaultExtensionRegistry(),
                    theme: parsed.theme || null
                };
                console.log('[Settings] Loaded settings.yaml');
                return notebookSettings;
            } catch (e) {
                // settings.yaml doesn't exist, try to migrate from legacy format
                console.log('[Settings] No settings.yaml found, checking for legacy files...');
            }

            // Try to migrate from notebook.json + extensions.yaml
            let title = 'Research Notebook';
            let subtitle = 'Bookmarks, notes, and connections';
            let sections = [];
            let extensions = getDefaultExtensionRegistry();
            let needsMigration = false;

            // Try to read notebook.json
            try {
                const metaFile = await dirHandle.getFileHandle('notebook.json');
                const file = await metaFile.getFile();
                const meta = JSON.parse(await file.text());
                title = meta.title || title;
                subtitle = meta.subtitle || subtitle;
                sections = meta.sections || [];
                needsMigration = true;
                console.log('[Settings] Found legacy notebook.json');
            } catch (e) {
                // No notebook.json
            }

            // Try to read extensions.yaml
            try {
                const extFile = await dirHandle.getFileHandle('extensions.yaml');
                const file = await extFile.getFile();
                const content = await file.text();
                const parsed = jsyaml.load(content);
                extensions = parsed.extensions || extensions;
                needsMigration = true;
                console.log('[Settings] Found legacy extensions.yaml');
            } catch (e) {
                // No extensions.yaml
            }

            notebookSettings = {
                notebook_title: title,
                notebook_subtitle: subtitle,
                sections: normalizeSectionsFormat(sections),
                extensions: extensions,
                theme: null
            };

            // Perform migration if legacy files were found
            if (needsMigration) {
                console.log('[Settings] Migrating to settings.yaml...');
                try {
                    await saveSettings(dirHandle);
                    // Delete legacy files after successful migration
                    try {
                        await dirHandle.removeEntry('notebook.json');
                        console.log('[Settings] Deleted legacy notebook.json');
                    } catch (e) { /* file might not exist */ }
                    try {
                        await dirHandle.removeEntry('extensions.yaml');
                        console.log('[Settings] Deleted legacy extensions.yaml');
                    } catch (e) { /* file might not exist */ }
                    showToast('Migrated notebook settings to settings.yaml');
                } catch (e) {
                    console.error('[Settings] Migration failed:', e);
                }
            }

            return notebookSettings;
        }

        // Normalize sections format: convert string array to records format
        // Old format: ['research', 'projects']
        // New format: [{name: 'research', visible: true}, {name: 'projects', visible: true}]
        function normalizeSectionsFormat(sections) {
            if (!Array.isArray(sections)) return [];
            return sections.map(s => {
                if (typeof s === 'string') {
                    return { name: s, visible: true };
                }
                // Already an object, ensure visible has a default
                return { name: s.name || '', visible: s.visible !== false };
            });
        }

        // Convert sections records to simple names array for filesystem operations
        function getSectionNames(sections) {
            return normalizeSectionsFormat(sections).map(s => s.name);
        }

        // Check if the _system section is visible in settings
        function getSystemSectionVisible() {
            if (!notebookSettings?.sections) return false;
            const systemSection = notebookSettings.sections.find(s =>
                (typeof s === 'string' ? s : s.name) === '_system'
            );
            if (!systemSection) return false;
            return typeof systemSection === 'string' ? true : systemSection.visible !== false;
        }

        // Save settings to settings.yaml
        async function saveSettings(dirHandle) {
            if (!dirHandle || !notebookSettings) return;

            const content = jsyaml.dump(notebookSettings, {
                indent: 2,
                lineWidth: -1,
                quotingType: '"',
                forceQuotes: false
            });

            const settingsFile = await dirHandle.getFileHandle('settings.yaml', { create: true });
            const writable = await settingsFile.createWritable();
            await writable.write(content);
            await writable.close();
            console.log('[Settings] Saved settings.yaml');
        }

        // Load extension registry from settings (or use defaults)
        async function loadExtensionRegistry(dirHandle) {
            // If settings already loaded, use extensions from there
            if (notebookSettings && notebookSettings.extensions) {
                extensionRegistry = notebookSettings.extensions;
                console.log('[Templates] Using extensions from settings');
                return extensionRegistry;
            }

            // Fallback: load from filesystem or defaults (legacy path)
            if (!dirHandle) {
                extensionRegistry = getDefaultExtensionRegistry();
                return extensionRegistry;
            }

            try {
                const extFile = await dirHandle.getFileHandle('extensions.yaml');
                const file = await extFile.getFile();
                const content = await file.text();
                const parsed = jsyaml.load(content);
                extensionRegistry = parsed.extensions || getDefaultExtensionRegistry();
                console.log('[Templates] Loaded extensions.yaml (legacy)');
            } catch (e) {
                // File doesn't exist, use defaults
                extensionRegistry = getDefaultExtensionRegistry();
                console.log('[Templates] Using default extension registry');
            }
            return extensionRegistry;
        }

        // Load templates from filesystem (merged with defaults)
        async function loadTemplates(dirHandle) {
            // Start with default templates (ensures settings is always available)
            const defaults = getDefaultTemplates();
            templateRegistry = { ...defaults };

            if (!dirHandle) {
                return templateRegistry;
            }

            // Scan root directory for .template.yaml files and merge with defaults
            const templatesToUpdate = [];
            try {
                for await (const [name, handle] of dirHandle.entries()) {
                    if (handle.kind === 'file' && name.endsWith('.template.yaml')) {
                        try {
                            const file = await handle.getFile();
                            const content = await file.text();
                            const template = jsyaml.load(content);
                            if (template && template.name) {
                                // Deep merge: user overrides win, but new default fields are inherited
                                const defaultTemplate = defaults[template.name];
                                const mergedTemplate = defaultTemplate
                                    ? deepMerge(defaultTemplate, template)
                                    : template;
                                templateRegistry[template.name] = mergedTemplate;

                                // Check if merge added new fields - if so, save updated template
                                if (defaultTemplate) {
                                    const mergedYaml = jsyaml.dump(mergedTemplate, { indent: 2, lineWidth: -1, quotingType: '"', forceQuotes: false });
                                    if (mergedYaml !== content) {
                                        templatesToUpdate.push({ name, handle, content: mergedYaml });
                                        console.log(`[Templates] Loaded ${name} (will update with new defaults)`);
                                    } else {
                                        console.log(`[Templates] Loaded ${name}`);
                                    }
                                } else {
                                    console.log(`[Templates] Loaded ${name} (custom template)`);
                                }
                            }
                        } catch (e) {
                            console.error(`[Templates] Error parsing ${name}:`, e);
                        }
                    }
                }
            } catch (e) {
                console.error('[Templates] Error scanning for templates:', e);
            }

            // Save any templates that were updated with new defaults
            for (const { name, handle, content } of templatesToUpdate) {
                try {
                    const writable = await handle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    console.log(`[Templates] Updated ${name} with new defaults`);
                } catch (e) {
                    console.error(`[Templates] Error saving ${name}:`, e);
                }
            }

            return templateRegistry;
        }

        // Load theme.css from notebook directory (user CSS overrides)
        async function loadThemeCss(dirHandle) {
            if (!dirHandle) return;

            // Remove any existing theme style element
            const existingTheme = document.getElementById('theme-css');
            if (existingTheme) {
                existingTheme.remove();
            }

            try {
                const themeFile = await dirHandle.getFileHandle('theme.css');
                const file = await themeFile.getFile();
                const content = await file.text();

                // Create and inject style element
                const style = document.createElement('style');
                style.id = 'theme-css';
                style.textContent = content;
                document.head.appendChild(style);
                console.log('[Theme] Loaded theme.css');
            } catch (e) {
                // File doesn't exist, that's fine
                console.log('[Theme] No theme.css found (optional)');
            }
        }

        // Inject CSS variables from template style definitions
        function injectTemplateStyles() {
            // Remove any existing template styles
            const existing = document.getElementById('template-styles');
            if (existing) {
                existing.remove();
            }

            // Core variables that templates should not override
            const protectedVars = ['--code-bg', '--code-text', '--bg-primary', '--bg-secondary',
                                   '--text-primary', '--text-secondary', '--text-muted', '--accent',
                                   '--border', '--shadow', '--link-color', '--link-hover', '--note-border'];

            const rules = Object.values(templateRegistry).map(t => {
                if (!t.style?.variables) return '';

                const vars = Object.entries(t.style.variables)
                    .filter(([k]) => !protectedVars.includes(k))
                    .map(([k, v]) => `${k}: ${v};`)
                    .join('\n  ');

                return `.card[data-template="${t.name}"],
.modal.viewer[data-template="${t.name}"] {
  ${vars}
}`;
            }).filter(r => r);

            if (rules.length > 0) {
                const style = document.createElement('style');
                style.id = 'template-styles';
                style.textContent = rules.join('\n\n');
                document.head.appendChild(style);
                console.log('[Templates] Injected template CSS variables');
            }
        }

        // Ensure template files exist in notebook (called on save if missing)
        async function ensureTemplateFiles(dirHandle) {
            if (!dirHandle) return;

            const filesToCreate = [
                { name: 'settings.yaml', getContent: getDefaultSettingsContent },
                { name: 'theme.css', getContent: getDefaultThemeContent },
                { name: 'note.template.yaml', getContent: () => getTemplateFileContent('note') },
                { name: 'code.template.yaml', getContent: () => getTemplateFileContent('code') },
                { name: 'bookmark.template.yaml', getContent: () => getTemplateFileContent('bookmark') }
            ];

            let createdFiles = [];

            for (const { name, getContent } of filesToCreate) {
                try {
                    await dirHandle.getFileHandle(name);
                    // File exists, don't overwrite
                } catch (e) {
                    // File doesn't exist, create it
                    try {
                        const fileHandle = await dirHandle.getFileHandle(name, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(getContent());
                        await writable.close();
                        createdFiles.push(name);
                        console.log(`[Templates] Created ${name}`);
                    } catch (writeError) {
                        console.error(`[Templates] Error creating ${name}:`, writeError);
                    }
                }
            }

            if (createdFiles.length > 0) {
                showToast(` Created template files: ${createdFiles.join(', ')}`);
            }

            return createdFiles;
        }

        // Ensure template files exist for card types that are already in use
        // This supports customization of existing cards without auto-creating
        // templates the user may have intentionally removed
        async function ensureTemplatesForExistingCards(dirHandle, loadedData) {
            if (!dirHandle) return [];

            // Collect all template types in use across all sections
            const templateTypesInUse = new Set();
            for (const section of loadedData.sections || []) {
                for (const item of section.items || []) {
                    const templateName = item.template || item.type;
                    if (templateName) {
                        templateTypesInUse.add(templateName);
                    }
                }
            }

            if (templateTypesInUse.size === 0) {
                return [];
            }

            // Map template names to their file names
            const templateToFile = {
                'note': 'note.template.yaml',
                'code': 'code.template.yaml',
                'bookmark': 'bookmark.template.yaml'
            };

            let createdFiles = [];

            for (const templateName of templateTypesInUse) {
                const filename = templateToFile[templateName];
                if (!filename) continue;  // Skip unknown/custom templates

                // Check if template file exists
                try {
                    await dirHandle.getFileHandle(filename);
                    // File exists, don't create
                } catch (e) {
                    // File doesn't exist but cards of this type exist, create it
                    try {
                        const content = getTemplateFileContent(templateName);
                        const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(content);
                        await writable.close();
                        createdFiles.push(filename);
                        console.log(`[Templates] Created ${filename} for existing ${templateName} cards`);

                        // Add to systemNotes so it appears in System section
                        const parsed = jsyaml.load(content);
                        loadedData.systemNotes.push({
                            template: 'template',
                            system: true,
                            id: 'system-' + filename,
                            filename: filename,
                            title: templateName + ' (template)',
                            name: parsed.name || templateName,
                            description: parsed.description || '',
                            schema: parsed.schema || {},
                            card: parsed.card || {},
                            viewer: parsed.viewer || {},
                            editor: parsed.editor || {},
                            style: parsed.style || {},
                            ui: parsed.ui || {},
                            modified: new Date().toISOString()
                        });
                    } catch (writeError) {
                        console.error(`[Templates] Error creating ${filename}:`, writeError);
                    }
                }
            }

            if (createdFiles.length > 0) {
                showToast(` Created templates for existing cards: ${createdFiles.join(', ')}`);
                // Reload templates so the registry has the newly created templates
                await loadTemplates(dirHandle);
            }

            return createdFiles;
        }

        // ===== Parsers =====
        // Parse file content based on parser type from extension registry

        const parsers = {
            // Parse markdown with YAML frontmatter
            'yaml-frontmatter': {
                parse(content) {
                    const match = content.match(/^---\n([\s\S]*?)\n---\n?([\s\S]*)$/);
                    if (match) {
                        // Parse frontmatter as simple key-value (not full YAML to avoid issues)
                        const frontmatter = {};
                        match[1].split('\n').forEach(line => {
                            const m = line.match(/^(\w+):\s*(.*)$/);
                            if (m) {
                                frontmatter[m[1]] = m[2];
                            }
                        });
                        return {
                            frontmatter,
                            body: match[2].trim() || null
                        };
                    }
                    // No frontmatter, entire content is body
                    return { frontmatter: {}, body: content };
                }
            },

            // Parse Python with comment-based frontmatter
            'comment-frontmatter': {
                parse(content) {
                    const lines = content.split('\n');
                    const frontmatter = {};
                    let bodyStart = 0;
                    let inFrontmatter = false;

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        if (line === '# ---') {
                            if (!inFrontmatter) {
                                inFrontmatter = true;
                                continue;
                            } else {
                                bodyStart = i + 1;
                                break;
                            }
                        }
                        if (inFrontmatter) {
                            const match = line.match(/^# (\w+):\s*(.*)$/);
                            if (match) {
                                let value = match[2];
                                // Convert boolean strings
                                if (value === 'true') value = true;
                                else if (value === 'false') value = false;
                                frontmatter[match[1]] = value;
                            }
                        } else if (line.trim() && !line.startsWith('#')) {
                            // Non-comment, non-empty line before frontmatter - no frontmatter
                            bodyStart = 0;
                            break;
                        }
                    }

                    return {
                        frontmatter,
                        body: lines.slice(bodyStart).join('\n').trim() || null
                    };
                }
            },

            // Parse JSON file
            'json': {
                parse(content) {
                    return { frontmatter: JSON.parse(content), body: null };
                }
            },

            // Parse YAML file
            'yaml': {
                parse(content) {
                    return { frontmatter: jsyaml.load(content), body: null };
                }
            }
        };

        // ===== Serializers =====
        // Serialize card data back to file content

        const serializers = {
            // Serialize to markdown with YAML frontmatter
            'yaml-frontmatter': {
                serialize(frontmatter, body) {
                    const lines = ['---'];
                    for (const [key, value] of Object.entries(frontmatter)) {
                        if (value !== undefined && value !== null) {
                            lines.push(`${key}: ${value}`);
                        }
                    }
                    lines.push('---', '');
                    if (body) {
                        lines.push(body);
                    }
                    return lines.join('\n');
                }
            },

            // Serialize to Python with comment-based frontmatter
            'comment-frontmatter': {
                serialize(frontmatter, body) {
                    const lines = ['# ---'];
                    for (const [key, value] of Object.entries(frontmatter)) {
                        if (value !== undefined && value !== null) {
                            lines.push(`# ${key}: ${value}`);
                        }
                    }
                    lines.push('# ---', '');
                    if (body) {
                        lines.push(body);
                    }
                    return lines.join('\n');
                }
            },

            // Serialize to JSON
            'json': {
                serialize(frontmatter, body) {
                    return JSON.stringify(frontmatter, null, 2);
                }
            },

            // Serialize to YAML
            'yaml': {
                serialize(frontmatter, body) {
                    return jsyaml.dump(frontmatter, { indent: 2, lineWidth: -1 });
                }
            }
        };

        // Get extension config for a filename
        function getExtensionConfig(filename) {
            if (!extensionRegistry) {
                extensionRegistry = getDefaultExtensionRegistry();
            }
            // Check extensions in order of specificity (longer matches first)
            const extensions = Object.keys(extensionRegistry).sort((a, b) => b.length - a.length);
            for (const ext of extensions) {
                if (filename.endsWith(ext)) {
                    return { extension: ext, config: extensionRegistry[ext] };
                }
            }
            return null;
        }

        // Load a card from file content using extension registry
        function loadCard(filename, content, sectionName, companionData = {}) {
            const extMatch = getExtensionConfig(filename);
            if (!extMatch) {
                console.warn(`[Templates] Unknown extension for ${filename}`);
                return null;
            }

            const { extension, config } = extMatch;
            const parser = parsers[config.parser];
            if (!parser) {
                console.warn(`[Templates] Unknown parser: ${config.parser}`);
                return null;
            }

            // Parse file content
            const { frontmatter, body } = parser.parse(content);

            // Determine template (frontmatter overrides extension default)
            const templateName = frontmatter.template || config.defaultTemplate;
            if (!templateName) {
                console.warn(`[Templates] No template specified for ${filename}`);
                return null;
            }

            // Assign body to bodyField (defined by extension)
            if (body && config.bodyField) {
                frontmatter[config.bodyField] = body;
            }

            // Add companion file data
            if (config.companionFiles) {
                for (const companion of config.companionFiles) {
                    if (companionData[companion.field]) {
                        frontmatter[companion.field] = companionData[companion.field];
                    }
                }
            }

            // Generate ID if missing
            if (!frontmatter.id) {
                frontmatter.id = Date.now().toString();
            }

            // For backwards compatibility, set 'type' field based on template
            // This ensures existing render functions work
            frontmatter.type = templateName;

            // Set language for code files (required by render functions)
            if (extension === '.code.py') {
                frontmatter.language = 'python';
            }

            // Store source info for saving
            frontmatter._source = {
                filename,
                format: config.parser,
                section: sectionName,
                extension
            };

            // For backwards compatibility with old code, also store _filename
            if (extension === '.md') {
                frontmatter._filename = filename;
            } else if (extension === '.code.py') {
                frontmatter._filename = filename.replace('.code.py', '');
            } else if (extension === '.bookmark.json') {
                frontmatter._filename = filename.replace('.bookmark.json', '');
            }

            return frontmatter;
        }

        // Prepare card data for saving (serialize to file content)
        function serializeCard(card) {
            // Determine format from _source or derive from type
            let format, bodyField, extension;

            if (card._source) {
                const extConfig = extensionRegistry[card._source.extension];
                format = card._source.format;
                bodyField = extConfig?.bodyField;
                extension = card._source.extension;
            } else {
                // New card - determine format from template/type
                if (card.type === 'note' || card.template === 'note') {
                    format = 'yaml-frontmatter';
                    bodyField = 'content';
                    extension = '.md';
                } else if (card.type === 'code' || card.template === 'code') {
                    format = 'comment-frontmatter';
                    bodyField = 'code';
                    extension = '.code.py';
                } else if (card.type === 'bookmark' || card.template === 'bookmark') {
                    format = 'json';
                    bodyField = null;
                    extension = '.bookmark.json';
                } else {
                    format = 'yaml';
                    bodyField = null;
                    extension = '.card.yaml';
                }
            }

            // Clone card data without internal fields
            const { _source, _filename, type, ...cardData } = card;

            // Extract body field for formats that separate it
            let body = null;
            const frontmatter = { ...cardData };

            if (bodyField && format !== 'yaml' && format !== 'json') {
                body = frontmatter[bodyField];
                delete frontmatter[bodyField];
            }

            // For JSON format (bookmarks), keep all fields together
            if (format === 'json') {
                frontmatter.type = type;  // Keep type for backwards compatibility
            }

            const serializer = serializers[format];
            const content = serializer.serialize(frontmatter, body);

            return { content, extension, format, bodyField };
        }

        // ===== Generic Card Rendering =====
        // Template-driven card rendering that replaces type-specific renderers

        // Render a card using its template definition
        function renderCard(sectionId, card) {
            const template = templateRegistry[card.template || card.type];
            if (!template) {
                console.warn(`[Render] Unknown template: ${card.template || card.type}`);
                return '';
            }

            const preview = renderCardPreview(card, template);
            const title = renderCardTitle(card, template);
            const meta = renderCardMeta(card, template);

            // Check if title should be a link (template-driven)
            const titleLinkField = template.card?.title_link_field;
            const titleLinkUrl = titleLinkField ? card[titleLinkField] : null;
            const titleHtml = titleLinkUrl
                ? `<a href="${escapeHtml(titleLinkUrl)}" target="_blank" onclick="event.stopPropagation()" title="Open link">${escapeHtml(title)}</a>`
                : escapeHtml(title);

            return `
                <div class="card"
                     data-template="${template.name}"
                     data-item-id="${card.id}"
                     data-section-id="${sectionId}"
                     onclick="openViewer('${sectionId}', '${card.id}')">
                    <div class="card-preview">${preview}</div>
                    <div class="card-content">
                        <h3 class="card-title">${titleHtml}</h3>
                    </div>
                    <div class="card-meta">
                        ${meta}
                    </div>
                </div>
            `;
        }

        // Render card preview based on template layout
        function renderCardPreview(card, template) {
            const layout = template.card?.layout || 'document';
            const placeholder = template.card?.placeholder || '';

            switch (layout) {
                case 'document':
                    return renderDocumentPreview(card, template);
                case 'image':
                    return renderImagePreview(card, template);
                case 'split-pane':
                    return renderSplitPanePreview(card, template);
                case 'fields':
                    return renderFieldsPreview(card, template);
                case 'yaml':
                    return renderYamlPreview(card, template);
                default:
                    return `<div class="preview-placeholder">${placeholder}</div>`;
            }
        }

        // Document layout: rendered markdown content
        function renderDocumentPreview(card, template) {
            const field = template.card?.preview_field || 'content';
            const content = card[field];
            const placeholder = template.card?.placeholder || '';

            if (!content) {
                return `<div class="preview-placeholder">${placeholder}</div>`;
            }

            // Check field type for rendering
            const fieldDef = template.schema?.[field];
            const fieldType = fieldDef?.type || 'text';
            const format = card.format || 'markdown';

            if (fieldType === 'yaml') {
                // YAML fields: convert object to string for preview
                const yamlStr = typeof content === 'object' ? jsyaml.dump(content, { indent: 2, lineWidth: -1 }) : String(content);
                return `<pre class="preview-code">${escapeHtml(yamlStr.substring(0, 400))}</pre>`;
            } else if (fieldType === 'code') {
                // Code fields: monospace with language class (check before 'content' field name)
                const codePreview = escapeHtml(content.substring(0, 400));
                return `<pre class="preview-code"><code class="language-${fieldDef?.language || 'python'}">${codePreview || 'No code'}</code></pre>`;
            } else if (fieldType === 'markdown' || field === 'content') {
                // Use existing renderNotePreview for markdown
                const previewHtml = renderNotePreview(content, format);
                if (!previewHtml) {
                    return `<div class="preview-placeholder">${placeholder}</div>`;
                }
                return `<div class="preview-page"><div class="preview-scaler"><div class="preview-content">${previewHtml}</div></div></div>`;
            } else if (typeof content === 'object') {
                // Handle any object that slipped through
                const str = JSON.stringify(content, null, 2);
                return `<pre class="preview-code">${escapeHtml(str.substring(0, 400))}</pre>`;
            } else {
                return `<div class="preview-text">${escapeHtml(String(content).substring(0, 300))}</div>`;
            }
        }

        // Image layout: thumbnail/image preview
        function renderImagePreview(card, template) {
            const field = template.card?.preview_field || 'thumbnail';
            const src = card[field];
            const placeholder = template.card?.placeholder || '';

            if (!src) {
                return `<div class="preview-placeholder">${placeholder}</div>`;
            }
            return `<img src="${escapeHtml(src)}" alt="" loading="lazy" class="preview-image" onerror="this.parentElement.innerHTML='<div class=\\'preview-placeholder\\'>${placeholder}</div>'">`;
        }

        // Split-pane layout: left/right split
        function renderSplitPanePreview(card, template) {
            const slots = template.card?.slots;
            const placeholder = template.card?.placeholder || '';

            if (!slots) {
                return renderDocumentPreview(card, template);
            }

            const leftField = slots.left?.field;
            const rightField = slots.right?.field;
            const leftContent = card[leftField];
            const rightContent = card[rightField];

            // If no left content (e.g., no output), fall back to simpler layout
            if (!leftContent && template.card?.fallback_layout) {
                const fallbackField = template.card?.fallback_field || rightField;
                const fallbackContent = card[fallbackField];
                if (!fallbackContent) {
                    return `<div class="preview-placeholder">${placeholder}</div>`;
                }
                // Render as code preview for code template
                const leftFieldDef = template.schema?.[fallbackField];
                if (leftFieldDef?.type === 'code') {
                    const codePreview = escapeHtml(fallbackContent.substring(0, 400));
                    return `<pre class="preview-code"><code class="language-${leftFieldDef?.language || 'python'}">${codePreview}</code></pre>`;
                }
                return `<div class="preview-text">${escapeHtml(fallbackContent.substring(0, 300))}</div>`;
            }

            // Render split pane
            const leftWidth = slots.left?.width || '60%';
            const rightWidth = slots.right?.width || '40%';

            // Determine how to render each side based on field type
            const leftFieldDef = template.schema?.[leftField];
            const rightFieldDef = template.schema?.[rightField];

            let leftHtml = '';
            if (leftFieldDef?.type === 'html') {
                leftHtml = `<div class="split-output-content">${leftContent || ''}</div>`;
            } else {
                leftHtml = `<div class="split-content">${escapeHtml(leftContent || '')}</div>`;
            }

            let rightHtml = '';
            if (rightFieldDef?.type === 'code') {
                const codePreview = escapeHtml((rightContent || '').substring(0, 400));
                rightHtml = `<pre class="split-code"><code class="language-${rightFieldDef?.language || 'python'}">${codePreview}</code></pre>`;
            } else {
                rightHtml = `<div class="split-content">${escapeHtml((rightContent || '').substring(0, 300))}</div>`;
            }

            return `
                <div class="preview-split">
                    <div class="preview-split-left" style="flex: 0 0 ${leftWidth}">
                        ${leftHtml}
                    </div>
                    <div class="preview-split-right" style="flex: 1">
                        ${rightHtml}
                    </div>
                </div>
            `;
        }

        // Fields layout: key-value display
        function renderFieldsPreview(card, template) {
            const fields = template.card?.preview_fields || Object.keys(template.schema || {}).slice(0, 3);
            const placeholder = template.card?.placeholder || '';

            if (fields.length === 0) {
                return `<div class="preview-placeholder">${placeholder}</div>`;
            }

            return `<div class="preview-fields">
                ${fields.map(f => `
                    <div class="preview-field">
                        <span class="preview-field-label">${f}:</span>
                        <span class="preview-field-value">${escapeHtml(card[f] || '')}</span>
                    </div>
                `).join('')}
            </div>`;
        }

        // YAML layout: show all schema fields as YAML
        function renderYamlPreview(card, template) {
            const placeholder = template.card?.placeholder || '';
            const schema = template.schema || {};

            // Build object from schema fields (excluding internal fields)
            const previewObj = {};
            for (const field of Object.keys(schema)) {
                if (card[field] !== undefined && card[field] !== null) {
                    previewObj[field] = card[field];
                }
            }

            if (Object.keys(previewObj).length === 0) {
                return `<div class="preview-placeholder">${placeholder}</div>`;
            }

            const yamlStr = jsyaml.dump(previewObj, { indent: 2, lineWidth: -1 });
            return `<pre class="preview-yaml">${escapeHtml(yamlStr)}</pre>`;
        }

        // Render card title (may use template formatting)
        function renderCardTitle(card, template) {
            if (template.card?.title_template) {
                // Simple template replacement: {{field}}
                return template.card.title_template.replace(/\{\{(\w+)\}\}/g, (match, field) => {
                    return card[field] || '';
                });
            }
            return card.title || 'Untitled';
        }

        // Render card metadata
        function renderCardMeta(card, template) {
            const created = card.created || card.modified;
            const modified = card.modified;

            let meta = `<span>${formatDate(created)}</span>`;
            if (modified && created && modified !== created) {
                meta += `<span>Updated ${formatDate(modified)}</span>`;
            }
            return meta;
        }

        // ===== Generic Viewer =====
        // Template-driven viewer that replaces type-specific viewers

        let currentViewingCard = null;

        function openViewer(sectionId, itemId) {
            let card;
            const isSystemNote = sectionId === '_system';

            if (isSystemNote) {
                card = data.systemNotes?.find(n => n.id === itemId);
            } else {
                const section = data.sections.find(s => s.id === sectionId);
                if (section) {
                    card = section.items.find(i => i.id === itemId);
                }
            }

            if (!card) {
                console.warn(`[Viewer] Card not found: ${sectionId}/${itemId}`);
                return;
            }

            const template = templateRegistry[card.template || card.type];
            if (!template) {
                console.warn(`[Viewer] Unknown template: ${card.template || card.type}`);
                return;
            }

            currentViewingCard = { ...card, sectionId };

            // Set title
            document.getElementById('viewerTitle').textContent = card.title || 'Untitled';

            // Render content based on viewer layout
            const contentEl = document.getElementById('viewerContent');
            contentEl.innerHTML = renderViewerContent(card, template);

            // Apply syntax highlighting if needed
            contentEl.querySelectorAll('pre code').forEach(el => {
                if (!el.getAttribute('data-highlighted')) {
                    hljs.highlightElement(el);
                }
            });

            // Add backlinks
            const backlinks = findBacklinks(itemId);
            const backlinksEl = document.getElementById('viewerBacklinks');
            if (backlinks.length > 0) {
                backlinksEl.innerHTML = `
                    <div class="backlinks">
                        <div class="backlinks-title">Linked from</div>
                        <div class="backlinks-list">
                            ${backlinks.map(bl => `
                                <span class="backlink-item internal-link" data-link-section="${bl.sectionId}" data-link-item="${bl.id}">${escapeHtml(bl.title)}</span>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                backlinksEl.innerHTML = '';
            }

            // Set meta info
            let metaText;
            if (isSystemNote) {
                metaText = card.modified ? `Modified ${formatDate(card.modified)}` : '';
            } else {
                metaText = formatDate(card.created || card.modified);
                if (card.modified && card.created && card.modified !== card.created) {
                    metaText += `  Updated ${formatDate(card.modified)}`;
                }
            }
            document.getElementById('viewerMeta').textContent = metaText;

            // Configure action buttons based on template
            const actionsEl = document.getElementById('viewerActions');
            actionsEl.innerHTML = renderViewerActions(card, template, isSystemNote);

            // Set template attribute on modal for CSS styling
            const modal = document.getElementById('viewerModal');
            modal.querySelector('.modal').setAttribute('data-template', template.name);
            modal.classList.add('active');
        }

        function renderViewerContent(card, template) {
            const layout = template.viewer?.layout || 'document';

            switch (layout) {
                case 'document':
                    return renderViewerDocument(card, template);
                case 'image':
                    return renderViewerImage(card, template);
                case 'split-pane':
                    return renderViewerSplitPane(card, template);
                case 'sections':
                    return renderViewerSections(card, template);
                case 'yaml':
                    return renderViewerYaml(card, template);
                default:
                    return renderViewerDocument(card, template);
            }
        }

        // Document viewer: single content area
        function renderViewerDocument(card, template) {
            const field = template.viewer?.content_field || 'content';
            const content = card[field];
            const format = card.format || 'markdown';

            if (!content) {
                return '<div class="viewer-empty">No content</div>';
            }

            // Check field type
            const fieldDef = template.schema?.[field];
            const fieldType = fieldDef?.type || 'text';

            if (fieldType === 'yaml') {
                // YAML fields: convert object to YAML string for display
                const yamlStr = typeof content === 'object' ? jsyaml.dump(content, { indent: 2, lineWidth: -1 }) : content;
                return `<pre class="viewer-text">${escapeHtml(yamlStr)}</pre>`;
            } else if (format === 'text' || format === 'yaml' || fieldType === 'text') {
                return `<pre class="viewer-text">${escapeHtml(content)}</pre>`;
            } else if (fieldType === 'code') {
                return `<div class="viewer-code"><pre><code class="language-${fieldDef?.language || 'python'}">${escapeHtml(content)}</code></pre></div>`;
            } else {
                return `<div class="viewer-markdown">${renderMarkdownWithLinks(content)}</div>`;
            }
        }

        // YAML viewer: show all schema fields as YAML
        function renderViewerYaml(card, template) {
            const schema = template.schema || {};

            // Build object from schema fields
            const viewObj = {};
            for (const field of Object.keys(schema)) {
                if (card[field] !== undefined && card[field] !== null) {
                    viewObj[field] = card[field];
                }
            }

            if (Object.keys(viewObj).length === 0) {
                return '<div class="viewer-empty">No content</div>';
            }

            const yamlStr = jsyaml.dump(viewObj, { indent: 2, lineWidth: -1 });
            return `<pre class="viewer-yaml">${escapeHtml(yamlStr)}</pre>`;
        }

        // Image viewer: large image with description
        function renderViewerImage(card, template) {
            const imageField = template.viewer?.image_field || 'thumbnail';
            const contentField = template.viewer?.content_field || 'description';
            const src = card[imageField];
            const content = card[contentField];
            const url = card.url;

            let html = '<div class="viewer-image-container">';

            if (src) {
                html += `<div class="viewer-thumbnail"><img src="${escapeHtml(src)}" alt="" onerror="this.parentElement.innerHTML='<div class=\\'placeholder\\'></div>'"></div>`;
            } else {
                html += '<div class="viewer-thumbnail"><div class="placeholder"></div></div>';
            }

            if (url) {
                html += `<div class="viewer-url"><a href="${escapeHtml(url)}" target="_blank">${escapeHtml(url)}</a></div>`;
            }

            if (content) {
                html += `<div class="viewer-description">${renderMarkdownWithLinks(content)}</div>`;
            }

            html += '</div>';
            return html;
        }

        // Split-pane viewer: side-by-side
        function renderViewerSplitPane(card, template) {
            const slots = template.viewer?.slots;
            if (!slots) {
                return renderViewerDocument(card, template);
            }

            const leftField = slots.left?.field;
            const rightField = slots.right?.field;
            const leftContent = card[leftField];
            const rightContent = card[rightField];
            const leftWidth = slots.left?.width || '60%';

            // If no left content, show code-only view
            if (!leftContent) {
                const rightFieldDef = template.schema?.[rightField];
                if (rightFieldDef?.type === 'code') {
                    return `<div class="viewer-code-only"><pre><code class="language-${rightFieldDef?.language || 'python'}">${escapeHtml(rightContent || '')}</code></pre></div>`;
                }
                return `<div class="viewer-text-only">${escapeHtml(rightContent || '')}</div>`;
            }

            // Render split pane
            const leftFieldDef = template.schema?.[leftField];
            const rightFieldDef = template.schema?.[rightField];

            let leftHtml = '';
            if (leftFieldDef?.type === 'html') {
                leftHtml = `<div class="viewer-output-content">${leftContent}</div>`;
            } else {
                leftHtml = `<div class="viewer-content">${escapeHtml(leftContent)}</div>`;
            }

            let rightHtml = '';
            if (rightFieldDef?.type === 'code') {
                rightHtml = `<pre><code class="language-${rightFieldDef?.language || 'python'}">${escapeHtml(rightContent || '')}</code></pre>`;
            } else {
                rightHtml = `<div class="viewer-content">${escapeHtml(rightContent || '')}</div>`;
            }

            return `
                <div class="viewer-split-pane">
                    <div class="viewer-split-left" style="flex: 0 0 ${leftWidth}">
                        ${leftHtml}
                    </div>
                    <div class="viewer-split-right">
                        ${rightHtml}
                    </div>
                </div>
            `;
        }

        // Sections viewer: labeled sections
        function renderViewerSections(card, template) {
            const sections = template.viewer?.sections || [];
            if (sections.length === 0) {
                return renderViewerDocument(card, template);
            }

            return sections.map(section => {
                const content = card[section.field];
                if (!content) return '';

                const fieldDef = template.schema?.[section.field];
                let html = '';

                if (fieldDef?.type === 'markdown') {
                    html = renderMarkdownWithLinks(content);
                } else {
                    html = `<p>${escapeHtml(content)}</p>`;
                }

                return `
                    <div class="viewer-section">
                        <h3 class="viewer-section-title">${escapeHtml(section.label)}</h3>
                        <div class="viewer-section-content">${html}</div>
                    </div>
                `;
            }).join('');
        }

        // Render viewer action buttons based on template
        function renderViewerActions(card, template, isSystemNote) {
            const templateName = template.name;
            let actions = '';

            // Template-specific actions
            if (templateName === 'bookmark' && card.url) {
                actions += `<a href="${escapeHtml(card.url)}" target="_blank" class="btn btn-primary btn-small">Open </a>`;
            }
            if (templateName === 'code') {
                actions += `<button class="btn btn-run btn-small" onclick="runViewerCode()"> Run</button>`;
            }

            // Common actions
            actions += `<button class="btn btn-secondary btn-small" onclick="editViewerCard()"> Edit</button>`;
            actions += `<button class="btn btn-secondary btn-small" onclick="deleteViewerCard()"> Delete</button>`;

            return actions;
        }

        function closeViewer() {
            document.getElementById('viewerModal').classList.remove('active');
            currentViewingCard = null;
        }

        function editViewerCard() {
            if (!currentViewingCard) return;
            const sectionId = currentViewingCard.sectionId;
            const card = { ...currentViewingCard };
            const templateName = card.template || card.type || 'note';
            closeViewer();

            // Use generic editor (Phase 3)
            openEditor(templateName, sectionId, card);
        }

        async function deleteViewerCard() {
            if (!currentViewingCard) return;
            const sectionId = currentViewingCard.sectionId;
            const cardId = currentViewingCard.id;
            const isSystemNote = sectionId === '_system';
            const templateName = currentViewingCard.template || currentViewingCard.type;
            closeViewer();

            if (isSystemNote) {
                if (!confirm('Delete this system note? The file will be removed from your notebook folder.')) return;

                const note = data.systemNotes?.find(n => n.id === cardId);
                if (note && notebookDirHandle) {
                    try {
                        await notebookDirHandle.removeEntry(note.filename);
                    } catch (e) {
                        console.warn('[Filesystem] Could not delete system note file:', e);
                    }
                }

                data.systemNotes = data.systemNotes?.filter(n => n.id !== cardId) || [];
                await saveData();
                render();
                showToast('System note deleted');
            } else {
                await confirmDeleteItem(sectionId, cardId, templateName);
            }
        }

        async function runViewerCode() {
            if (!currentViewingCard) return;

            // Show running status
            const contentEl = document.getElementById('viewerContent');
            contentEl.innerHTML = '<div class="viewer-loading">Running...</div>';

            try {
                const py = await initPyodide();
                const result = await executePythonCode(py, currentViewingCard.code);

                // Update stored output
                const section = data.sections.find(s => s.id === currentViewingCard.sectionId);
                if (section) {
                    const codeNote = section.items.find(c => c.id === currentViewingCard.id);
                    if (codeNote) {
                        codeNote.output = result;
                        codeNote.modified = new Date().toISOString();
                        currentViewingCard.output = result;
                        await saveData();
                        await saveCardFile(currentViewingCard.sectionId, codeNote);
                        render();

                        // Re-render the viewer with new output
                        openViewer(currentViewingCard.sectionId, currentViewingCard.id);
                    }
                }
            } catch (error) {
                contentEl.innerHTML = `<div class="viewer-error"><pre class="error">${escapeHtml(error.toString())}</pre></div>`;
            }
        }

        // ========== SECTION: GENERIC_EDITOR ==========
        // Generic editor modal for all card types (Phase 3 Template System)
        // Functions: openEditor, closeEditor, saveEditor, renderEditorField, getEditorFieldValue,
        //            handleEditorAction, initEditorThumbnailUpload, runEditorCode

        // State for generic editor
        let editingCard = null;  // { templateName, sectionId, card, isNew }
        let editorManualThumbnail = null;  // For thumbnail field uploads

        // CodeMirror editor instances (field name -> EditorView)
        let codeMirrorInstances = {};
        let codeMirrorLoaded = false;
        let codeMirrorModules = null;  // Cached imports: { EditorView, basicSetup, python, yaml, css }

        // Load CodeMirror modules (lazy, once)
        async function loadCodeMirror() {
            if (codeMirrorModules) return codeMirrorModules;
            if (codeMirrorLoaded) {
                // Wait for loading to complete
                while (!codeMirrorModules) {
                    await new Promise(r => setTimeout(r, 50));
                }
                return codeMirrorModules;
            }
            codeMirrorLoaded = true;
            try {
                const [cm, langPython, langYaml, langCss, langMarkdown, themeOneDark, cmCommands, cmView, cmLanguage, lezerHighlight] = await Promise.all([
                    import('codemirror'),
                    import('@codemirror/lang-python'),
                    import('@codemirror/lang-yaml'),
                    import('@codemirror/lang-css'),
                    import('@codemirror/lang-markdown'),
                    import('@codemirror/theme-one-dark'),
                    import('@codemirror/commands'),
                    import('@codemirror/view'),
                    import('@codemirror/language'),
                    import('@lezer/highlight')
                ]);
                // Create custom markdown highlight style with warm, readable colors
                const t = lezerHighlight.tags;
                const markdownHighlightStyle = cmLanguage.HighlightStyle.define([
                    { tag: t.heading1, color: '#8b4513', fontSize: '1.4em', fontWeight: 'bold' },
                    { tag: t.heading2, color: '#8b4513', fontSize: '1.25em', fontWeight: 'bold' },
                    { tag: t.heading3, color: '#8b4513', fontSize: '1.1em', fontWeight: 'bold' },
                    { tag: t.heading4, color: '#8b4513', fontWeight: 'bold' },
                    { tag: t.heading5, color: '#8b4513', fontWeight: 'bold' },
                    { tag: t.heading6, color: '#8b4513', fontWeight: 'bold' },
                    { tag: t.heading, color: '#8b4513', fontWeight: 'bold' },
                    { tag: t.strong, fontWeight: 'bold', color: '#2d3748' },
                    { tag: t.emphasis, fontStyle: 'italic', color: '#4a5568' },
                    { tag: t.strikethrough, textDecoration: 'line-through', color: '#718096' },
                    { tag: t.link, color: '#2b6cb0', textDecoration: 'underline' },
                    { tag: t.url, color: '#3182ce' },
                    { tag: t.monospace, color: '#c53030', backgroundColor: '#fef2f2', fontFamily: 'monospace' },
                    { tag: t.quote, color: '#6b7280', fontStyle: 'italic', borderLeft: '3px solid #d1d5db' },
                    { tag: t.list, color: '#7c3aed' },
                    { tag: t.contentSeparator, color: '#9ca3af' },
                    { tag: t.processingInstruction, color: '#9ca3af' },  // For markdown markers like #, *, etc.
                    { tag: t.meta, color: '#9ca3af' }  // For frontmatter, etc.
                ]);

                codeMirrorModules = {
                    EditorView: cm.EditorView,
                    basicSetup: cm.basicSetup,
                    minimalSetup: cm.minimalSetup,
                    python: langPython.python,
                    yaml: langYaml.yaml,
                    css: langCss.css,
                    markdown: langMarkdown.markdown,
                    oneDark: themeOneDark.oneDark,
                    markdownHighlightStyle: markdownHighlightStyle,
                    syntaxHighlighting: cmLanguage.syntaxHighlighting,
                    indentWithTab: cmCommands.indentWithTab,
                    keymap: cmView.keymap,
                    lineNumbers: cmView.lineNumbers,
                    highlightActiveLine: cmView.highlightActiveLine,
                    highlightActiveLineGutter: cmView.highlightActiveLineGutter
                };
                console.log('[CodeMirror] Loaded successfully');
                return codeMirrorModules;
            } catch (err) {
                console.error('[CodeMirror] Failed to load:', err);
                codeMirrorLoaded = false;
                throw err;
            }
        }

        // Create a CodeMirror editor in a container element
        async function createCodeMirrorEditor(container, options = {}) {
            const { language = 'python', value = '', fieldName = '' } = options;
            const cm = await loadCodeMirror();

            // Get language extension
            let langExtension;
            switch (language) {
                case 'yaml': langExtension = cm.yaml(); break;
                case 'css': langExtension = cm.css(); break;
                case 'markdown': langExtension = cm.markdown(); break;
                case 'python':
                default: langExtension = cm.python(); break;
            }

            // Build extensions based on language type
            const isMarkdown = language === 'markdown';
            const extensions = [
                // Use minimal setup for markdown (no line numbers), basic for code
                isMarkdown ? cm.minimalSetup : cm.basicSetup,
                langExtension,
                cm.keymap.of([cm.indentWithTab]),
                cm.EditorView.theme({
                    '&': { height: '100%' },
                    '.cm-scroller': { overflow: 'auto' }
                })
            ];

            // Add theme: custom light theme for markdown, One Dark for code
            if (isMarkdown) {
                // Light theme with custom markdown syntax highlighting
                extensions.push(cm.EditorView.theme({
                    '&': {
                        backgroundColor: '#faf8f5',
                        color: '#3a3632'
                    },
                    '.cm-content': {
                        caretColor: '#4a4542',
                        fontFamily: 'ui-monospace, SFMono-Regular, "SF Mono", Menlo, Monaco, Consolas, monospace',
                        fontSize: '14px',
                        lineHeight: '1.6'
                    },
                    '.cm-cursor': {
                        borderLeftColor: '#4a4542'
                    },
                    '&.cm-focused .cm-selectionBackground, .cm-selectionBackground': {
                        backgroundColor: '#d7d4cf'
                    },
                    '.cm-activeLine': {
                        backgroundColor: '#f0ebe0'
                    }
                }, { dark: false }));
                extensions.push(cm.syntaxHighlighting(cm.markdownHighlightStyle));
                extensions.push(cm.highlightActiveLine());
            } else {
                // Dark theme for code/yaml/css
                extensions.push(cm.oneDark);
            }

            // Create editor
            const editor = new cm.EditorView({
                doc: value,
                extensions,
                parent: container
            });

            // Store instance if field name provided
            if (fieldName) {
                codeMirrorInstances[fieldName] = editor;
            }

            return editor;
        }

        // Get value from a CodeMirror instance by field name
        function getCodeMirrorValue(fieldName) {
            const editor = codeMirrorInstances[fieldName];
            return editor ? editor.state.doc.toString() : '';
        }

        // Destroy all CodeMirror instances (call when closing editor)
        function destroyCodeMirrorInstances() {
            for (const [name, editor] of Object.entries(codeMirrorInstances)) {
                editor.destroy();
            }
            codeMirrorInstances = {};
        }

        // Open the generic editor modal
        function openEditor(templateName, sectionId, card = null) {
            const template = templateRegistry[templateName];
            if (!template) {
                showToast(`Unknown template: ${templateName}`);
                return;
            }

            const isNew = !card;
            editingCard = {
                templateName,
                sectionId,
                card: card || { id: generateId(), template: templateName },
                isNew
            };
            editorManualThumbnail = null;

            // Set modal data-template for CSS
            const modal = document.querySelector('#editorModal .modal');
            modal.setAttribute('data-template', templateName);

            // Set title
            const buttonLabel = template.ui?.button_label || templateName;
            document.getElementById('editorTitle').textContent = isNew ? `New ${buttonLabel}` : `Edit ${buttonLabel}`;

            // Build form body
            const bodyEl = document.getElementById('editorBody');
            bodyEl.innerHTML = '';

            // Section selector (for regular cards, not system notes)
            if (sectionId !== '_system') {
                const sectionGroup = document.createElement('div');
                sectionGroup.className = 'form-group';
                sectionGroup.innerHTML = `
                    <label for="editorSection">Section</label>
                    <select id="editorSection">
                        ${data.sections.map(s => `
                            <option value="${s.id}" ${s.id === sectionId ? 'selected' : ''}>${escapeHtml(s.name)}</option>
                        `).join('')}
                    </select>
                `;
                bodyEl.appendChild(sectionGroup);
            }

            // Render each field from template.editor.fields
            const fields = template.editor?.fields || [];
            for (const fieldConfig of fields) {
                const fieldDef = template.schema[fieldConfig.field];
                const value = card ? card[fieldConfig.field] : (fieldDef?.default || '');
                const fieldEl = renderEditorField(fieldConfig, fieldDef, value);
                bodyEl.appendChild(fieldEl);
            }

            // Handle output display for code templates
            const outputEl = document.getElementById('editorOutput');
            const outputContentEl = document.getElementById('editorCodeOutput');
            if (template.schema?.output && card?.output) {
                outputEl.style.display = 'block';
                outputContentEl.innerHTML = card.output;
            } else {
                outputEl.style.display = 'none';
                outputContentEl.innerHTML = '';
            }

            // Render action buttons (Run, etc.) and special controls
            const actionsEl = document.getElementById('editorActions');
            const actions = template.editor?.actions || [];
            let actionsHtml = '';

            // Standard action buttons
            if (actions.length > 0) {
                actionsHtml = actions.map(action => {
                    if (action.action === 'execute') {
                        return `
                            <button class="btn btn-run btn-small" id="editorRunBtn" onclick="runEditorCode()">
                                ${action.icon || ''} ${action.label}
                            </button>
                            <span class="editor-status" id="editorStatus"></span>
                        `;
                    }
                    return `<button class="btn btn-secondary btn-small" onclick="handleEditorAction('${action.action}')">${action.icon || ''} ${action.label}</button>`;
                }).join('');
            }

            // Settings-specific: add storage info and system notes toggle
            if (templateName === 'settings') {
                const folderName = notebookDirHandle ? notebookDirHandle.name : 'Not linked';
                actionsHtml += `
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="font-size: 12px; color: var(--text-muted);">
                             <code style="background: var(--bg-secondary); padding: 2px 6px; border-radius: 3px;">${escapeHtml(folderName)}</code>
                        </span>
                        <button class="btn btn-secondary btn-small" onclick="refreshFromFilesystem()" title="Reload from filesystem"> Refresh</button>
                        <button class="btn btn-secondary btn-small" onclick="changeNotebookFolder()" title="Switch notebook folder"> Change</button>
                    </div>
                `;
            }

            actionsEl.innerHTML = actionsHtml;

            // Update Pyodide status if this is a code template
            if (templateName === 'code') {
                updateEditorPyodideStatus();
            }

            // Set submit button text
            document.getElementById('editorSubmitBtn').textContent = isNew ? `Save ${buttonLabel}` : 'Save Changes';

            // Show modal
            document.getElementById('editorModal').classList.add('active');

            // Focus first input
            const firstInput = bodyEl.querySelector('input, textarea');
            if (firstInput) {
                setTimeout(() => firstInput.focus(), 100);
            }

            // Initialize thumbnail upload if present
            initEditorThumbnailUpload();
        }

        // Render a single editor field based on its configuration
        function renderEditorField(fieldConfig, fieldDef, value) {
            const { field, label, width, multiline, rows, monospace, preview, widget, auto_fetch } = fieldConfig;
            const type = fieldDef?.type || 'text';
            const required = fieldDef?.required || false;

            const div = document.createElement('div');
            div.className = `form-group ${width === 'half' ? 'form-field-half' : ''}`;
            div.setAttribute('data-field', field);

            const labelEl = document.createElement('label');
            labelEl.setAttribute('for', `editor-${field}`);
            labelEl.textContent = label + (required ? ' *' : '');
            div.appendChild(labelEl);

            let inputEl;

            // Handle different field types/widgets
            if (widget === 'thumbnail-upload' || type === 'thumbnail') {
                // Thumbnail upload widget
                const thumbnailDiv = document.createElement('div');
                thumbnailDiv.className = 'thumbnail-upload';
                thumbnailDiv.id = 'editorThumbnailPreview';
                thumbnailDiv.innerHTML = `
                    <div class="thumbnail-placeholder">
                        <span class="thumbnail-icon"></span>
                        <p class="thumbnail-hint">Drag & drop image here<br>or click to upload</p>
                    </div>
                    <input type="file" id="editorThumbnailFile" accept="image/*" style="display: none">
                `;
                if (value) {
                    thumbnailDiv.classList.add('has-image');
                    thumbnailDiv.style.backgroundImage = `url('${value}')`;
                    thumbnailDiv.style.backgroundSize = 'cover';
                    thumbnailDiv.style.backgroundPosition = 'center';
                }
                div.appendChild(thumbnailDiv);
            } else if (type === 'markdown' && preview) {
                // Markdown with preview tabs and CodeMirror editor
                const tabsDiv = document.createElement('div');
                tabsDiv.className = 'editor-tabs';
                tabsDiv.innerHTML = `
                    <button type="button" class="editor-tab active" onclick="switchEditorTab('write')">Write</button>
                    <button type="button" class="editor-tab" onclick="switchEditorTab('preview')">Preview</button>
                `;
                div.appendChild(tabsDiv);

                // CodeMirror container for markdown editing
                const editorContainer = document.createElement('div');
                editorContainer.id = `editor-${field}`;
                editorContainer.className = 'codemirror-container markdown-editor';
                editorContainer.setAttribute('data-language', 'markdown');
                editorContainer.setAttribute('data-field', field);
                div.appendChild(editorContainer);

                // Initialize CodeMirror async
                createCodeMirrorEditor(editorContainer, {
                    language: 'markdown',
                    value: value || '',
                    fieldName: field
                }).catch(err => {
                    console.error('Failed to initialize CodeMirror for markdown:', err);
                    // Fallback to textarea
                    editorContainer.innerHTML = `<textarea class="markdown-editor-fallback" style="width:100%;height:300px;">${escapeHtml(value || '')}</textarea>`;
                });

                const previewDiv = document.createElement('div');
                previewDiv.id = 'editorPreview';
                previewDiv.className = 'editor-preview';
                div.appendChild(previewDiv);

                const hint = document.createElement('p');
                hint.className = 'form-hint';
                hint.textContent = 'Supports Markdown and LaTeX ($inline$, $$display$$). Link with [[Title]] or [[id:xyz]]';
                div.appendChild(hint);
            } else if (type === 'yaml') {
                // YAML editor with CodeMirror
                // Convert object to YAML string for editing
                let yamlValue = '';
                if (value && typeof value === 'object') {
                    yamlValue = jsyaml.dump(value, { indent: 2, lineWidth: -1 });
                } else if (typeof value === 'string') {
                    yamlValue = value;
                }

                const editorContainer = document.createElement('div');
                editorContainer.id = `editor-${field}`;
                editorContainer.className = 'codemirror-container';
                editorContainer.setAttribute('data-language', 'yaml');
                editorContainer.setAttribute('data-field', field);
                div.appendChild(editorContainer);

                // Initialize CodeMirror async
                createCodeMirrorEditor(editorContainer, {
                    language: 'yaml',
                    value: yamlValue,
                    fieldName: field
                }).catch(err => {
                    console.error('Failed to initialize CodeMirror for YAML:', err);
                    // Fallback to textarea
                    editorContainer.innerHTML = `<textarea class="code-editor" style="width:100%;height:300px;">${escapeHtml(yamlValue)}</textarea>`;
                });

                const yamlHint = document.createElement('p');
                yamlHint.className = 'form-hint';
                yamlHint.textContent = 'Edit YAML configuration. Invalid YAML will show an error on save.';
                div.appendChild(yamlHint);
            } else if (type === 'code' || (multiline && monospace)) {
                // Code editor with CodeMirror
                // Determine language from fieldConfig or default to python
                const language = fieldConfig.language || 'python';

                const editorContainer = document.createElement('div');
                editorContainer.id = `editor-${field}`;
                editorContainer.className = 'codemirror-container';
                editorContainer.setAttribute('data-language', language);
                editorContainer.setAttribute('data-field', field);
                div.appendChild(editorContainer);

                // Initialize CodeMirror async
                createCodeMirrorEditor(editorContainer, {
                    language: language,
                    value: value || '',
                    fieldName: field
                }).catch(err => {
                    console.error('Failed to initialize CodeMirror for code:', err);
                    // Fallback to textarea
                    editorContainer.innerHTML = `<textarea class="code-editor" style="width:100%;height:300px;">${escapeHtml(value || '')}</textarea>`;
                });
            } else if (type === 'markdown') {
                // Markdown field without preview tabs - use CodeMirror with markdown highlighting
                const editorContainer = document.createElement('div');
                editorContainer.id = `editor-${field}`;
                editorContainer.className = 'codemirror-container codemirror-markdown-compact';
                editorContainer.setAttribute('data-language', 'markdown');
                editorContainer.setAttribute('data-field', field);
                // Set height based on rows config
                editorContainer.style.height = `${(rows || 4) * 24}px`;
                div.appendChild(editorContainer);

                // Initialize CodeMirror async
                createCodeMirrorEditor(editorContainer, {
                    language: 'markdown',
                    value: value || '',
                    fieldName: field
                }).catch(err => {
                    console.error('Failed to initialize CodeMirror for markdown:', err);
                    // Fallback to textarea
                    editorContainer.innerHTML = `<textarea style="width:100%;height:100%;">${escapeHtml(value || '')}</textarea>`;
                });
            } else if (multiline) {
                // Regular textarea for non-markdown multiline
                inputEl = document.createElement('textarea');
                inputEl.id = `editor-${field}`;
                inputEl.rows = rows || 4;
                inputEl.placeholder = label;
                inputEl.value = value || '';
                div.appendChild(inputEl);
            } else if (type === 'url') {
                // URL input
                inputEl = document.createElement('input');
                inputEl.type = 'url';
                inputEl.id = `editor-${field}`;
                inputEl.placeholder = 'https://example.com';
                inputEl.value = value || '';
                if (auto_fetch) {
                    inputEl.setAttribute('data-auto-fetch', 'true');
                }
                div.appendChild(inputEl);
            } else if (type === 'number') {
                inputEl = document.createElement('input');
                inputEl.type = 'number';
                inputEl.id = `editor-${field}`;
                inputEl.value = value || '';
                div.appendChild(inputEl);
            } else if (type === 'boolean') {
                inputEl = document.createElement('input');
                inputEl.type = 'checkbox';
                inputEl.id = `editor-${field}`;
                inputEl.checked = !!value;
                div.appendChild(inputEl);
            } else if (type === 'date') {
                inputEl = document.createElement('input');
                inputEl.type = 'date';
                inputEl.id = `editor-${field}`;
                inputEl.value = value ? value.split('T')[0] : '';
                div.appendChild(inputEl);
            } else if (type === 'datetime') {
                inputEl = document.createElement('input');
                inputEl.type = 'datetime-local';
                inputEl.id = `editor-${field}`;
                inputEl.value = value ? value.slice(0, 16) : '';
                div.appendChild(inputEl);
            } else if (type === 'enum' && fieldDef?.options) {
                inputEl = document.createElement('select');
                inputEl.id = `editor-${field}`;
                fieldDef.options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt;
                    option.selected = opt === value;
                    inputEl.appendChild(option);
                });
                div.appendChild(inputEl);
            } else if (type === 'list') {
                // List editor with reorderable items
                const listContainer = document.createElement('div');
                listContainer.className = 'list-editor';
                listContainer.id = `editor-${field}`;
                listContainer.setAttribute('data-item-type', fieldDef?.item_type || 'text');
                const allowDelete = fieldDef?.allowDelete !== false;
                const allowAdd = fieldDef?.allowAdd !== false;
                listContainer.setAttribute('data-allow-delete', allowDelete);

                const itemsArray = Array.isArray(value) ? value : [];
                itemsArray.forEach((item, idx) => {
                    const itemRow = createListEditorItem(field, item, idx, allowDelete);
                    listContainer.appendChild(itemRow);
                });

                div.appendChild(listContainer);

                // Add button (only if allowAdd is true)
                if (allowAdd) {
                    const addBtn = document.createElement('button');
                    addBtn.type = 'button';
                    addBtn.className = 'list-editor-add';
                    addBtn.textContent = '+ Add item';
                    addBtn.onclick = () => {
                        const container = document.getElementById(`editor-${field}`);
                        const newIdx = container.children.length;
                        const canDelete = container.getAttribute('data-allow-delete') === 'true';
                        const newRow = createListEditorItem(field, '', newIdx, canDelete);
                        container.appendChild(newRow);
                        // Focus the new input
                        const input = newRow.querySelector('input');
                        if (input) input.focus();
                    };
                    div.appendChild(addBtn);
                }
            } else if (type === 'records') {
                // Records editor - list of objects with defined schema
                const recordsContainer = document.createElement('div');
                recordsContainer.className = 'records-editor';
                recordsContainer.id = `editor-${field}`;
                const schema = fieldDef?.schema || {};
                const allowDelete = fieldDef?.allowDelete !== false;
                const allowAdd = fieldDef?.allowAdd !== false;
                recordsContainer.setAttribute('data-schema', JSON.stringify(schema));
                recordsContainer.setAttribute('data-allow-delete', allowDelete);
                recordsContainer.setAttribute('data-allow-add', allowAdd);

                const recordsArray = Array.isArray(value) ? value : [];
                recordsArray.forEach((record, idx) => {
                    const recordRow = createRecordsEditorItem(field, schema, record, idx, allowDelete);
                    recordsContainer.appendChild(recordRow);
                });

                div.appendChild(recordsContainer);

                // Add button (only if allowAdd is true)
                if (allowAdd) {
                    const addBtn = document.createElement('button');
                    addBtn.type = 'button';
                    addBtn.className = 'records-editor-add';
                    addBtn.textContent = '+ Add item';
                    addBtn.onclick = () => {
                        const container = document.getElementById(`editor-${field}`);
                        const schemaStr = container.getAttribute('data-schema');
                        const schema = JSON.parse(schemaStr);
                        const canDelete = container.getAttribute('data-allow-delete') === 'true';
                        const newIdx = container.children.length;
                        // Create default record from schema
                        const defaultRecord = {};
                        for (const [key, def] of Object.entries(schema)) {
                            defaultRecord[key] = def.default !== undefined ? def.default : (def.type === 'boolean' ? true : '');
                        }
                        const newRow = createRecordsEditorItem(field, schema, defaultRecord, newIdx, canDelete);
                        container.appendChild(newRow);
                    };
                    div.appendChild(addBtn);
                }
            } else {
                // Default text input
                inputEl = document.createElement('input');
                inputEl.type = 'text';
                inputEl.id = `editor-${field}`;
                inputEl.placeholder = label;
                inputEl.value = value || '';
                div.appendChild(inputEl);
            }

            return div;
        }

        // Create a single list editor item row with up/down/delete buttons
        function createListEditorItem(field, value, index, allowDelete = true) {
            const row = document.createElement('div');
            row.className = 'list-editor-item';
            row.setAttribute('data-index', index);

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'list-editor-input';
            input.value = value || '';
            input.placeholder = 'Item value';
            input.readOnly = !allowDelete; // If can't delete, also can't edit (for sections)
            row.appendChild(input);

            const buttons = document.createElement('div');
            buttons.className = 'list-editor-buttons';

            // Move up button
            const upBtn = document.createElement('button');
            upBtn.type = 'button';
            upBtn.className = 'list-editor-btn';
            upBtn.textContent = '';
            upBtn.title = 'Move up';
            upBtn.onclick = () => moveListItem(field, row, -1);
            buttons.appendChild(upBtn);

            // Move down button
            const downBtn = document.createElement('button');
            downBtn.type = 'button';
            downBtn.className = 'list-editor-btn';
            downBtn.textContent = '';
            downBtn.title = 'Move down';
            downBtn.onclick = () => moveListItem(field, row, 1);
            buttons.appendChild(downBtn);

            // Delete button (only if allowed)
            if (allowDelete) {
                const delBtn = document.createElement('button');
                delBtn.type = 'button';
                delBtn.className = 'list-editor-btn list-editor-btn-delete';
                delBtn.textContent = '';
                delBtn.title = 'Remove';
                delBtn.onclick = () => {
                    row.remove();
                    updateListEditorIndices(field);
                };
                buttons.appendChild(delBtn);
            }

            row.appendChild(buttons);
            return row;
        }

        // Move a list item up or down
        function moveListItem(field, row, direction) {
            const container = document.getElementById(`editor-${field}`);
            const items = Array.from(container.children);
            const currentIndex = items.indexOf(row);
            const newIndex = currentIndex + direction;

            if (newIndex < 0 || newIndex >= items.length) return;

            if (direction < 0) {
                container.insertBefore(row, items[newIndex]);
            } else {
                container.insertBefore(items[newIndex], row);
            }
            updateListEditorIndices(field);
        }

        // Update data-index attributes after reordering
        function updateListEditorIndices(field) {
            const container = document.getElementById(`editor-${field}`);
            Array.from(container.children).forEach((row, idx) => {
                row.setAttribute('data-index', idx);
            });
        }

        // Create a single records editor item row
        function createRecordsEditorItem(field, schema, record, index, allowDelete) {
            const row = document.createElement('div');
            row.className = 'records-editor-item';
            row.setAttribute('data-index', index);

            // Create fields based on schema
            const fieldsContainer = document.createElement('div');
            fieldsContainer.className = 'records-editor-fields';

            for (const [key, def] of Object.entries(schema)) {
                const value = record[key];
                const fieldType = def.type || 'text';
                const readOnly = def.readOnly === true;

                if (fieldType === 'boolean') {
                    // Render as clickable icon toggle
                    const toggle = document.createElement('button');
                    toggle.type = 'button';
                    toggle.className = 'records-editor-toggle';
                    toggle.setAttribute('data-field', key);
                    toggle.setAttribute('data-value', value !== false ? 'true' : 'false');
                    toggle.title = def.label || key;
                    // Use eye icon for visibility
                    if (key === 'visible') {
                        toggle.textContent = value !== false ? '' : '';
                        toggle.classList.toggle('is-hidden', value === false);
                    } else {
                        toggle.textContent = value ? '' : '';
                    }
                    toggle.onclick = () => {
                        const current = toggle.getAttribute('data-value') === 'true';
                        const newVal = !current;
                        toggle.setAttribute('data-value', newVal ? 'true' : 'false');
                        if (key === 'visible') {
                            toggle.textContent = newVal ? '' : '';
                            toggle.classList.toggle('is-hidden', !newVal);
                            // Grey out the row when hidden
                            row.classList.toggle('is-hidden', !newVal);
                        } else {
                            toggle.textContent = newVal ? '' : '';
                        }
                    };
                    fieldsContainer.appendChild(toggle);
                } else {
                    // Text input
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'records-editor-input';
                    input.setAttribute('data-field', key);
                    input.value = value || '';
                    input.placeholder = def.label || key;
                    input.readOnly = readOnly;
                    if (readOnly) {
                        input.title = def.label || key;
                    }
                    fieldsContainer.appendChild(input);
                }
            }

            row.appendChild(fieldsContainer);

            // Buttons container
            const buttons = document.createElement('div');
            buttons.className = 'records-editor-buttons';

            // Move up button
            const upBtn = document.createElement('button');
            upBtn.type = 'button';
            upBtn.className = 'records-editor-btn';
            upBtn.textContent = '';
            upBtn.title = 'Move up';
            upBtn.onclick = () => moveRecordsItem(field, row, -1);
            buttons.appendChild(upBtn);

            // Move down button
            const downBtn = document.createElement('button');
            downBtn.type = 'button';
            downBtn.className = 'records-editor-btn';
            downBtn.textContent = '';
            downBtn.title = 'Move down';
            downBtn.onclick = () => moveRecordsItem(field, row, 1);
            buttons.appendChild(downBtn);

            // Delete button (only if allowed)
            if (allowDelete) {
                const delBtn = document.createElement('button');
                delBtn.type = 'button';
                delBtn.className = 'records-editor-btn records-editor-btn-delete';
                delBtn.textContent = '';
                delBtn.title = 'Remove';
                delBtn.onclick = () => {
                    row.remove();
                    updateRecordsEditorIndices(field);
                };
                buttons.appendChild(delBtn);
            }

            row.appendChild(buttons);

            // Set initial hidden state based on visible field
            if (record.visible === false) {
                row.classList.add('is-hidden');
            }

            return row;
        }

        // Move a records item up or down
        function moveRecordsItem(field, row, direction) {
            const container = document.getElementById(`editor-${field}`);
            const items = Array.from(container.children);
            const currentIndex = items.indexOf(row);
            const newIndex = currentIndex + direction;

            if (newIndex < 0 || newIndex >= items.length) return;

            if (direction < 0) {
                container.insertBefore(row, items[newIndex]);
            } else {
                container.insertBefore(items[newIndex], row);
            }
            updateRecordsEditorIndices(field);
        }

        // Update data-index attributes after reordering records
        function updateRecordsEditorIndices(field) {
            const container = document.getElementById(`editor-${field}`);
            Array.from(container.children).forEach((row, idx) => {
                row.setAttribute('data-index', idx);
            });
        }

        // Get value from an editor field
        function getEditorFieldValue(fieldName, fieldDef) {
            const type = fieldDef?.type || 'text';

            // Special handling for thumbnail
            if (type === 'thumbnail') {
                return editorManualThumbnail || editingCard.card[fieldName] || null;
            }

            // Check for CodeMirror instance first (for code and yaml types)
            if (codeMirrorInstances[fieldName]) {
                const cmValue = getCodeMirrorValue(fieldName);
                if (type === 'yaml') {
                    // Parse YAML string back to object
                    try {
                        return cmValue ? jsyaml.load(cmValue) : null;
                    } catch (e) {
                        console.error('[Editor] Invalid YAML:', e.message);
                        showToast('Invalid YAML: ' + e.message, true);
                        return null;
                    }
                }
                return cmValue;
            }

            const el = document.getElementById(`editor-${fieldName}`);
            if (!el) return null;

            if (type === 'boolean') {
                return el.checked;
            } else if (type === 'number') {
                return el.value ? parseFloat(el.value) : null;
            } else if (type === 'datetime' && el.value) {
                return new Date(el.value).toISOString();
            } else if (type === 'date' && el.value) {
                return el.value;
            } else if (type === 'yaml') {
                // Fallback for textarea (if CodeMirror failed to load)
                // Parse YAML string back to object
                try {
                    return el.value ? jsyaml.load(el.value) : null;
                } catch (e) {
                    console.error('[Editor] Invalid YAML:', e.message);
                    showToast('Invalid YAML: ' + e.message, true);
                    return null;
                }
            } else if (type === 'list') {
                // Collect values from list editor items in order
                const values = [];
                const rows = el.querySelectorAll('.list-editor-item');
                rows.forEach(row => {
                    const input = row.querySelector('.list-editor-input');
                    if (input && input.value.trim()) {
                        values.push(input.value.trim());
                    }
                });
                return values;
            } else if (type === 'records') {
                // Collect record objects from records editor items in order
                const schemaStr = el.getAttribute('data-schema');
                const schema = JSON.parse(schemaStr || '{}');
                const records = [];
                const rows = el.querySelectorAll('.records-editor-item');
                rows.forEach(row => {
                    const record = {};
                    for (const key of Object.keys(schema)) {
                        const fieldType = schema[key].type || 'text';
                        if (fieldType === 'boolean') {
                            const toggle = row.querySelector(`[data-field="${key}"]`);
                            record[key] = toggle ? toggle.getAttribute('data-value') === 'true' : true;
                        } else {
                            const input = row.querySelector(`[data-field="${key}"]`);
                            record[key] = input ? input.value : '';
                        }
                    }
                    records.push(record);
                });
                return records;
            }

            return el.value;
        }

        // Switch between write/preview tabs
        function switchEditorTab(tab) {
            const tabs = document.querySelectorAll('#editorBody .editor-tab');
            const editorContainer = document.querySelector('#editorBody .codemirror-container.markdown-editor');
            const fallbackTextarea = document.querySelector('#editorBody textarea.markdown-editor-fallback');
            const preview = document.getElementById('editorPreview');

            // Get the editor element (CodeMirror container or fallback textarea)
            const editorEl = editorContainer || fallbackTextarea;
            if (!editorEl || !preview) return;

            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            if (tab === 'preview') {
                editorEl.style.display = 'none';
                preview.style.display = 'block';
                preview.classList.add('active');

                // Render markdown preview - get content from CodeMirror or fallback textarea
                let content;
                if (editorContainer && codeMirrorInstances['content']) {
                    content = getCodeMirrorValue('content');
                } else if (fallbackTextarea) {
                    content = fallbackTextarea.value;
                } else {
                    content = '';
                }

                const format = editingCard.card.format || 'markdown';
                if (format === 'markdown') {
                    preview.innerHTML = renderMarkdownWithLinks(content);
                } else {
                    preview.innerHTML = `<pre>${escapeHtml(content)}</pre>`;
                }
            } else {
                editorEl.style.display = 'block';
                preview.style.display = 'none';
                preview.classList.remove('active');
            }
        }

        // Initialize thumbnail drag-drop for editor
        function initEditorThumbnailUpload() {
            const previewEl = document.getElementById('editorThumbnailPreview');
            const fileInput = document.getElementById('editorThumbnailFile');
            if (!previewEl || !fileInput) return;

            // Click to upload
            previewEl.addEventListener('click', () => fileInput.click());

            // File input change
            fileInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    handleEditorThumbnailFile(e.target.files[0]);
                }
            });

            // Drag and drop
            previewEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                previewEl.classList.add('drag-over');
            });

            previewEl.addEventListener('dragleave', () => {
                previewEl.classList.remove('drag-over');
            });

            previewEl.addEventListener('drop', (e) => {
                e.preventDefault();
                previewEl.classList.remove('drag-over');
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    handleEditorThumbnailFile(e.dataTransfer.files[0]);
                }
            });
        }

        // Handle thumbnail file selection
        function handleEditorThumbnailFile(file) {
            if (!file.type.startsWith('image/')) {
                showToast('Please select an image file');
                return;
            }
            if (file.size > 5 * 1024 * 1024) {
                showToast('Image must be smaller than 5MB');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                editorManualThumbnail = e.target.result;
                const previewEl = document.getElementById('editorThumbnailPreview');
                if (previewEl) {
                    previewEl.classList.add('has-image');
                    previewEl.style.backgroundImage = `url('${editorManualThumbnail}')`;
                    previewEl.style.backgroundSize = 'cover';
                    previewEl.style.backgroundPosition = 'center';
                }
            };
            reader.readAsDataURL(file);
        }

        // Update Pyodide status in editor
        function updateEditorPyodideStatus() {
            const statusEl = document.getElementById('editorStatus');
            if (!statusEl) return;

            if (pyodideReady) {
                statusEl.textContent = ' Python ready';
            } else if (pyodideLoading) {
                statusEl.textContent = ' Loading Python...';
            } else {
                statusEl.textContent = 'Will load on first run';
            }
        }

        // Run code in editor (for code template)
        async function runEditorCode() {
            const outputEl = document.getElementById('editorCodeOutput');
            const outputContainer = document.getElementById('editorOutput');
            const runBtn = document.getElementById('editorRunBtn');

            if (!outputEl) return;

            // Get code from CodeMirror instance or fallback to textarea
            let code = '';
            if (codeMirrorInstances['code']) {
                code = getCodeMirrorValue('code');
            } else {
                const codeEl = document.getElementById('editor-code');
                code = codeEl ? codeEl.value : '';
            }

            if (!code.trim()) {
                showToast('Please enter some code first');
                return;
            }

            // Show output area
            outputContainer.style.display = 'block';
            outputEl.innerHTML = '<div style="color: var(--text-muted);"> Running...</div>';

            if (runBtn) {
                runBtn.disabled = true;
                runBtn.innerHTML = ' Running...';
            }

            try {
                const py = await initPyodide();
                const result = await executePythonCode(py, code);
                outputEl.innerHTML = result;
            } catch (error) {
                outputEl.innerHTML = `<pre class="error">${escapeHtml(error.toString())}</pre>`;
            }

            if (runBtn) {
                runBtn.disabled = false;
                runBtn.innerHTML = ' Run';
            }

            updateEditorPyodideStatus();
        }

        // Close the editor modal
        function closeEditor() {
            // Clean up CodeMirror instances before clearing DOM
            destroyCodeMirrorInstances();

            document.getElementById('editorModal').classList.remove('active');
            document.getElementById('editorBody').innerHTML = '';
            document.getElementById('editorActions').innerHTML = '';
            document.getElementById('editorOutput').style.display = 'none';
            document.getElementById('editorCodeOutput').innerHTML = '';
            editingCard = null;
            editorManualThumbnail = null;
        }

        // Save the editor content
        async function saveEditor() {
            if (!editingCard) return;

            const { templateName, sectionId, card, isNew } = editingCard;
            const template = templateRegistry[templateName];
            if (!template) return;

            const submitBtn = document.getElementById('editorSubmitBtn');
            const originalText = submitBtn.textContent;

            // Validate required fields and collect values
            const fields = template.editor?.fields || [];
            const cardData = { ...card, template: templateName };
            let hasError = false;

            for (const fieldConfig of fields) {
                const fieldDef = template.schema[fieldConfig.field];
                const value = getEditorFieldValue(fieldConfig.field, fieldDef);

                if (fieldDef?.required && !value) {
                    showToast(`${fieldConfig.label} is required`);
                    hasError = true;
                    break;
                }

                cardData[fieldConfig.field] = value;
            }

            if (hasError) return;

            // Get selected section (may have changed)
            const sectionSelect = document.getElementById('editorSection');
            const newSectionId = sectionSelect ? sectionSelect.value : sectionId;

            // Set timestamps
            const now = new Date().toISOString();
            if (isNew) {
                cardData.created = now;
            }
            cardData.modified = now;

            // Handle thumbnail auto-generation for bookmarks
            if (templateName === 'bookmark' && cardData.url) {
                if (editorManualThumbnail) {
                    cardData.thumbnail = editorManualThumbnail;
                } else if (!cardData.thumbnail || isNew) {
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<span class="loading-spinner"></span> Generating thumbnail...';
                    try {
                        cardData.thumbnail = await generateThumbnail(cardData.url);
                    } catch (e) {
                        console.log('Thumbnail generation failed:', e);
                    }
                }
            }

            // Handle auto-execute for code
            if (templateName === 'code' && cardData.code) {
                submitBtn.disabled = true;
                submitBtn.innerHTML = ' Running & Saving...';
                try {
                    const py = await initPyodide();
                    cardData.output = await executePythonCode(py, cardData.code);
                    cardData.showOutput = true;
                } catch (e) {
                    cardData.output = `<pre class="error">${escapeHtml(e.toString())}</pre>`;
                }
            }

            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading-spinner"></span> Saving...';

            try {
                // Handle system notes
                if (sectionId === '_system') {
                    const idx = data.systemNotes.findIndex(n => n.id === card.id);
                    if (idx >= 0) {
                        // Preserve system note properties
                        cardData.system = true;
                        cardData.filename = card.filename;
                        data.systemNotes[idx] = { ...data.systemNotes[idx], ...cardData };
                    }
                    await saveData();
                    await saveCardFile('_system', cardData);
                    closeEditor();
                    render();
                    showToast('System note saved');
                    return;
                }

                // Handle section change
                if (!isNew && newSectionId !== sectionId) {
                    // Remove from old section
                    const oldSection = data.sections.find(s => s.id === sectionId);
                    if (oldSection) {
                        const idx = oldSection.items.findIndex(i => i.id === card.id);
                        if (idx >= 0) {
                            oldSection.items.splice(idx, 1);
                            // Delete old file
                            await deleteItemFile(sectionId, card);
                        }
                    }
                    // Add to new section
                    const newSection = data.sections.find(s => s.id === newSectionId);
                    if (newSection) {
                        newSection.items.push(cardData);
                    }
                } else {
                    // Same section - update or add
                    const section = data.sections.find(s => s.id === newSectionId);
                    if (section) {
                        if (isNew) {
                            section.items.push(cardData);
                        } else {
                            const idx = section.items.findIndex(i => i.id === card.id);
                            if (idx >= 0) {
                                // Handle title change (requires file rename)
                                if (card.title && card.title !== cardData.title) {
                                    await deleteItemFile(newSectionId, card);
                                }
                                section.items[idx] = cardData;
                            }
                        }
                    }
                }

                await saveData();
                await saveCardFile(newSectionId, cardData);

                closeEditor();
                render();
                showToast(isNew ? `${template.ui?.button_label || 'Card'} created` : 'Changes saved');

            } catch (error) {
                console.error('Save error:', error);
                showToast('Error saving: ' + error.message);
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        // Handle generic editor actions
        function handleEditorAction(action) {
            if (action === 'execute') {
                runEditorCode();
            }
            // Add other actions as needed
        }

        // ========== SECTION: DATA_PERSISTENCE ==========
        // IndexedDB operations: loadData, openDB, saveData
        // Storage config: IDB_NAME, IDB_STORE, IDB_KEY

        // Load data from IndexedDB
        async function loadData() {
            try {
                const db = await openDB();
                const tx = db.transaction(IDB_STORE, 'readonly');
                const store = tx.objectStore(IDB_STORE);

                const jsonStr = await new Promise((resolve, reject) => {
                    const request = store.get(IDB_KEY);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                db.close();

                if (jsonStr) {
                    data = JSON.parse(jsonStr);
                    // Ensure title and subtitle exist (backwards compatibility)
                    if (!data.title) data.title = 'Research Notebook';
                    if (!data.subtitle) data.subtitle = 'Bookmarks, notes, and connections';
                    console.log(`Loaded data from IndexedDB (${(jsonStr.length / 1024).toFixed(1)}KB)`);
                }
            } catch (error) {
                console.error('Error loading data:', error);
                showToast(' Error loading data: ' + error.message);
            }
            render();
        }

        // Storage configuration - using IndexedDB for reliable large dataset support
        const IDB_NAME = 'ResearchNotebookDB';
        const IDB_STORE = 'notebook';
        const IDB_KEY = 'data';

        // IndexedDB helper functions
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(IDB_NAME, 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(IDB_STORE)) {
                        db.createObjectStore(IDB_STORE);
                    }
                };
            });
        }

        // Save data to IndexedDB only (filesystem saves handled separately by targeted functions)
        async function saveData() {
            try {
                const jsonStr = JSON.stringify(data);
                const db = await openDB();
                const tx = db.transaction(IDB_STORE, 'readwrite');
                const store = tx.objectStore(IDB_STORE);
                store.put(jsonStr, IDB_KEY);

                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });

                db.close();
                console.log(`Data saved to IndexedDB (${(jsonStr.length / 1024).toFixed(1)}KB)`);
            } catch (error) {
                console.error('Error saving data:', error);
                showToast(' Error saving data: ' + error.message);
                throw error;
            }
        }

        // ========== SECTION: FILESYSTEM_STORAGE ==========
        // File System Access API integration for direct folder read/write
        // Functions: slugify, noteToMarkdown, markdownToNote, codeToFile, fileToCode,
        //            bookmarkToJson, jsonToBookmark, loadFromFilesystem, saveToFilesystem,
        //            saveDirHandle, loadDirHandle, linkNotebookFolder, unlinkNotebookFolder

        // Check if File System Access API is available
        function isFileSystemAccessSupported() {
            return 'showDirectoryPicker' in window;
        }

        // Template for README.md in notebook folders
        function getReadmeTemplate(notebookTitle) {
            return `# ${notebookTitle || 'Research Notebook'}

This folder contains a Research Notebook - a collection of notes, code snippets, and bookmarks stored as plain files.

## Directory Structure

\`\`\`
notebook-folder/
 notebook.json           # Notebook metadata (title, subtitle, section order)
 README.md               # This file
 CLAUDE.md               # Instructions for Claude Code
 sections/
    section-name/
        _section.json   # Section metadata
        note-title.md   # Markdown note with YAML frontmatter
        code-title.code.py     # Python code with comment frontmatter
        code-title.output.html # Code execution output (auto-generated)
        bookmark.bookmark.json # Bookmark metadata
 assets/
     thumbnails/         # Bookmark thumbnail images
\`\`\`

## File Formats

### Notes (\`.md\`)
Markdown files with YAML frontmatter:

\`\`\`markdown
---
id: abc123
title: My Note Title
created: 2024-01-15T10:30:00Z
modified: 2024-01-20T14:22:00Z
---

Note content in markdown...
\`\`\`

### Code (\`.code.py\`)
Python files with comment-based frontmatter:

\`\`\`python
# ---
# id: def456
# title: Analysis Script
# created: 2024-01-15T10:30:00Z
# modified: 2024-01-20T14:22:00Z
# output: analysis-script.output.html
# showOutput: true
# ---

import numpy as np
# Your code here...
\`\`\`

### Bookmarks (\`.bookmark.json\`)
JSON files with URL and metadata:

\`\`\`json
{
  "id": "ghi789",
  "type": "bookmark",
  "title": "Example Site",
  "url": "https://example.com",
  "description": "Description here",
  "thumbnail": "../../assets/thumbnails/ghi789.png",
  "created": "2024-01-15T10:30:00Z",
  "modified": "2024-01-20T14:22:00Z"
}
\`\`\`

## Git Workflow

This folder is designed for git version control:

\`\`\`bash
# Initialize git (first time only)
git init
git add .
git commit -m "Initial notebook"

# After making changes in the browser
git add .
git commit -m "Add notes on transformers"

# View history of a specific note
git log --oneline sections/papers/attention-mechanisms.md
\`\`\`

## Internal Links

Notes support wiki-style internal links:
- \`[[Section Name > Item Title]]\` - Links to another item
- Links work across notes, code, and bookmarks

## Opening the Notebook

Open \`research_notebook.html\` in Chrome/Edge and select this folder when prompted.
`;
        }

        // Template for CLAUDE.md in notebook folders
        function getClaudeMdTemplate() {
            return `# CLAUDE.md

This folder is a Research Notebook that stores notes, code, and bookmarks as plain files. You can read and edit these files directly.

## Quick Reference

| Type | Extension | Format |
|------|-----------|--------|
| Notes | \`.md\` | Markdown with YAML frontmatter |
| Code | \`.code.py\` | Python with comment frontmatter |
| Code Output | \`.output.html\` | HTML (auto-generated, don't edit) |
| Bookmarks | \`.bookmark.json\` | JSON |
| Thumbnails | \`assets/thumbnails/*.png\` | Images (auto-generated) |

## Reading Items

\`\`\`bash
# List all sections
ls sections/

# Read a note
cat sections/papers/attention-mechanisms.md

# Read code
cat sections/ideas/analysis.code.py

# Search across all notes
grep -r "transformer" sections/ --include="*.md"
\`\`\`

## Creating Items

### New Note
Create \`sections/{section-name}/{slug}.md\`:

\`\`\`markdown
---
id: unique-id-here
title: Your Note Title
created: 2024-01-15T10:30:00Z
modified: 2024-01-15T10:30:00Z
---

Your markdown content here...
\`\`\`

### New Code
Create \`sections/{section-name}/{slug}.code.py\`:

\`\`\`python
# ---
# id: unique-id-here
# title: Your Code Title
# created: 2024-01-15T10:30:00Z
# modified: 2024-01-15T10:30:00Z
# ---

# Your Python code here
\`\`\`

### New Section
1. Create directory: \`sections/{section-slug}/\`
2. Create \`sections/{section-slug}/_section.json\`:

\`\`\`json
{
  "name": "Section Display Name",
  "id": "unique-section-id"
}
\`\`\`
3. Add section slug to \`notebook.json\` sections array

## Editing Items

- Edit the file content directly
- Update the \`modified\` timestamp
- The browser app will auto-detect changes (Chrome 129+) or user can click Refresh

## Important Notes

- **Slugs**: Filenames should be lowercase, hyphenated versions of titles (max 50 chars)
- **IDs**: Each item needs a unique ID (use any string, e.g., timestamp or UUID)
- **Don't edit**: \`.output.html\` files (auto-generated when code runs)
- **Internal links**: Use \`[[Section Name > Item Title]]\` syntax in markdown
- **Thumbnails**: Bookmarks can reference \`../../assets/thumbnails/{id}.png\`

## Common Tasks

**Add a note summarizing a paper:**
> Create a new .md file in sections/papers/ with frontmatter and markdown content

**Search for all mentions of a topic:**
> grep -r "attention" sections/ --include="*.md" --include="*.code.py"

**List all items in a section:**
> ls sections/papers/

**Find items modified recently:**
> find sections/ -name "*.md" -mtime -7
`;
        }

        // Convert title to filename-safe slug
        function slugify(title, maxLength = 50) {
            if (!title) return 'untitled';
            let slug = title.toLowerCase();
            slug = slug.replace(/[^\w\s-]/g, '');  // Remove special chars
            slug = slug.replace(/[\s_]+/g, '-');   // Spaces to hyphens
            slug = slug.trim().replace(/^-+|-+$/g, '');  // Trim hyphens
            return slug.substring(0, maxLength) || 'untitled';
        }

        // Note: Old type-specific conversion functions (noteToMarkdown, markdownToNote,
        // codeToFile, fileToCode, bookmarkToJson, jsonToBookmark) have been replaced by
        // the generic loadCard() and serializeCard() functions in TEMPLATE_SYSTEM section.

        // Save directory handle to IndexedDB for persistence
        async function saveDirHandle(handle) {
            try {
                const db = await openDB();
                const tx = db.transaction(IDB_STORE, 'readwrite');
                const store = tx.objectStore(IDB_STORE);
                store.put(handle, IDB_DIR_HANDLE_KEY);
                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });
                db.close();
                console.log('[Filesystem] Directory handle saved to IndexedDB');
            } catch (error) {
                console.error('[Filesystem] Error saving directory handle:', error);
            }
        }

        // Load directory handle from IndexedDB
        async function loadDirHandle() {
            try {
                const db = await openDB();
                const tx = db.transaction(IDB_STORE, 'readonly');
                const store = tx.objectStore(IDB_STORE);
                const handle = await new Promise((resolve, reject) => {
                    const request = store.get(IDB_DIR_HANDLE_KEY);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                db.close();
                return handle || null;
            } catch (error) {
                console.error('[Filesystem] Error loading directory handle:', error);
                return null;
            }
        }

        // Request permission for directory handle (needed after page reload)
        async function verifyDirPermission(handle) {
            if (!handle) return false;
            try {
                const options = { mode: 'readwrite' };
                if (await handle.queryPermission(options) === 'granted') {
                    return true;
                }
                if (await handle.requestPermission(options) === 'granted') {
                    return true;
                }
                return false;
            } catch (error) {
                console.error('[Filesystem] Permission error:', error);
                return false;
            }
        }

        // Load notebook data from filesystem
        async function loadFromFilesystem(dirHandle) {
            console.log('[Filesystem] Loading from directory...');

            // Load settings first (handles migration from legacy format)
            await loadSettings(dirHandle);

            // Load extension registry (uses settings.extensions) and templates
            await loadExtensionRegistry(dirHandle);
            await loadTemplates(dirHandle);

            // Inject template CSS variables and load user theme
            injectTemplateStyles();
            await loadThemeCss(dirHandle);

            const loadedData = {
                title: notebookSettings?.notebook_title || 'Research Notebook',
                subtitle: notebookSettings?.notebook_subtitle || 'Bookmarks, notes, and connections',
                sections: [],
                systemNotes: []
            };

            try {

                // Read system notes (text files at root)
                // Include: .md, .txt, .yaml (including templates), .css
                // Exclude: .json, .html, .js, binary files, dotfiles
                const excludedExtensions = ['.json', '.html', '.js', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico'];

                for await (const [filename, fileHandle] of dirHandle.entries()) {
                    if (fileHandle.kind !== 'file') continue;

                    // Skip files with excluded extensions
                    if (excludedExtensions.some(ext => filename.endsWith(ext))) continue;

                    // Skip all dotfiles (hidden files)
                    if (filename.startsWith('.')) continue;

                    // Skip legacy config files
                    if (filename === 'notebook.json') continue;

                    try {
                        const file = await fileHandle.getFile();
                        const content = await file.text();

                        // Special handling for settings.yaml - use settings template
                        if (filename === 'settings.yaml') {
                            loadedData.systemNotes.push({
                                template: 'settings',
                                system: true,
                                id: 'system-settings.yaml',
                                filename: filename,
                                title: 'Settings',
                                // Store parsed settings fields
                                notebook_title: notebookSettings?.notebook_title || 'Research Notebook',
                                notebook_subtitle: notebookSettings?.notebook_subtitle || '',
                                sections: notebookSettings?.sections || [],
                                extensions: notebookSettings?.extensions || getDefaultExtensionRegistry(),
                                theme: notebookSettings?.theme || null,
                                modified: file.lastModified ? new Date(file.lastModified).toISOString() : new Date().toISOString()
                            });
                            console.log(`[Filesystem] Loaded settings card: ${filename}`);
                            continue;
                        }

                        // Special handling for *.template.yaml - use template template
                        if (filename.endsWith('.template.yaml')) {
                            try {
                                const parsed = jsyaml.load(content);
                                const templateName = filename.replace(/\.template\.yaml$/, '');
                                loadedData.systemNotes.push({
                                    template: 'template',
                                    system: true,
                                    id: 'system-' + filename,
                                    filename: filename,
                                    title: templateName + ' (template)',
                                    // Store parsed template fields
                                    name: parsed.name || templateName,
                                    description: parsed.description || '',
                                    schema: parsed.schema || {},
                                    card: parsed.card || {},
                                    viewer: parsed.viewer || {},
                                    editor: parsed.editor || {},
                                    style: parsed.style || {},
                                    ui: parsed.ui || {},
                                    modified: file.lastModified ? new Date(file.lastModified).toISOString() : new Date().toISOString()
                                });
                                console.log(`[Filesystem] Loaded template card: ${filename}`);
                            } catch (e) {
                                console.error(`[Filesystem] Error parsing template ${filename}:`, e);
                            }
                            continue;
                        }

                        // Special handling for theme.css - use theme template
                        if (filename === 'theme.css') {
                            loadedData.systemNotes.push({
                                template: 'theme',
                                system: true,
                                id: 'system-theme.css',
                                filename: filename,
                                title: 'Theme',
                                content: content,
                                modified: file.lastModified ? new Date(file.lastModified).toISOString() : new Date().toISOString()
                            });
                            console.log(`[Filesystem] Loaded theme card: ${filename}`);
                            continue;
                        }

                        // Determine format based on extension
                        const isMarkdown = filename.endsWith('.md');
                        const isYaml = filename.endsWith('.yaml');
                        let titleFromFilename = filename;
                        if (isMarkdown) titleFromFilename = filename.replace(/\.md$/, '');
                        else if (filename.endsWith('.template.yaml')) titleFromFilename = filename.replace(/\.template\.yaml$/, '') + ' (template)';
                        else if (isYaml) titleFromFilename = filename.replace(/\.yaml$/, '');

                        // Determine format for rendering
                        let format = 'text';
                        if (isMarkdown) format = 'markdown';
                        else if (isYaml) format = 'yaml';

                        loadedData.systemNotes.push({
                            type: 'note',
                            system: true,
                            id: 'system-' + filename,
                            filename: filename,
                            title: titleFromFilename,
                            content: content,
                            format: format,
                            modified: file.lastModified ? new Date(file.lastModified).toISOString() : new Date().toISOString()
                        });
                        console.log(`[Filesystem] Loaded system note: ${filename} (${format})`);
                    } catch (e) {
                        console.error(`[Filesystem] Error reading system note ${filename}:`, e);
                    }
                }

                // Read sections directory
                let sectionsDir;
                try {
                    sectionsDir = await dirHandle.getDirectoryHandle('sections');
                } catch (e) {
                    console.log('[Filesystem] No sections directory found');
                    return loadedData;
                }

                // Iterate through section directories
                for await (const [sectionName, sectionHandle] of sectionsDir.entries()) {
                    if (sectionHandle.kind !== 'directory') continue;

                    const section = {
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                        name: sectionName,
                        items: []
                    };

                    // Try to read section metadata for display name
                    try {
                        const sectionMetaFile = await sectionHandle.getFileHandle('_section.json');
                        const file = await sectionMetaFile.getFile();
                        const sectionMeta = JSON.parse(await file.text());
                        section.name = sectionMeta.name || sectionName;
                        section.id = sectionMeta.id || section.id;
                    } catch (e) {
                        // No metadata file, use directory name
                    }

                    // First pass: collect all files and identify companion files
                    const files = {};
                    const companionFiles = {};
                    for await (const [filename, fileHandle] of sectionHandle.entries()) {
                        if (fileHandle.kind !== 'file') continue;
                        if (filename.startsWith('_')) continue;  // Skip metadata files

                        // Check if this is a companion file (e.g., .output.html)
                        let isCompanion = false;
                        for (const ext of Object.keys(extensionRegistry)) {
                            const config = extensionRegistry[ext];
                            if (config.companionFiles) {
                                for (const companion of config.companionFiles) {
                                    if (filename.endsWith(companion.suffix)) {
                                        // Store companion content by base filename
                                        const baseFilename = filename.slice(0, -companion.suffix.length) + ext;
                                        if (!companionFiles[baseFilename]) companionFiles[baseFilename] = {};
                                        try {
                                            const file = await fileHandle.getFile();
                                            companionFiles[baseFilename][companion.field] = await file.text();
                                        } catch (e) {
                                            console.warn(`[Filesystem] Error reading companion file ${filename}:`, e);
                                        }
                                        isCompanion = true;
                                        break;
                                    }
                                }
                            }
                            if (isCompanion) break;
                        }

                        if (!isCompanion) {
                            files[filename] = fileHandle;
                        }
                    }

                    // Second pass: load cards with their companion data
                    for (const [filename, fileHandle] of Object.entries(files)) {
                        try {
                            const file = await fileHandle.getFile();
                            const content = await file.text();

                            // Get companion data for this file
                            const companionData = companionFiles[filename] || {};

                            // Special handling for bookmarks: load thumbnail from assets
                            if (filename.endsWith('.bookmark.json')) {
                                try {
                                    const bookmarkData = JSON.parse(content);
                                    if (bookmarkData.thumbnail && !bookmarkData.thumbnail.startsWith('data:')) {
                                        // It's a file path, need to load the actual image
                                        try {
                                            const assetsDir = await dirHandle.getDirectoryHandle('assets');
                                            const thumbsDir = await assetsDir.getDirectoryHandle('thumbnails');
                                            const thumbFilename = bookmarkData.thumbnail.split('/').pop();
                                            const thumbHandle = await thumbsDir.getFileHandle(thumbFilename);
                                            const thumbFile = await thumbHandle.getFile();

                                            const reader = new FileReader();
                                            companionData.thumbnail = await new Promise((resolve, reject) => {
                                                reader.onload = () => resolve(reader.result);
                                                reader.onerror = reject;
                                                reader.readAsDataURL(thumbFile);
                                            });
                                        } catch (e) {
                                            console.warn(`[Filesystem] Could not load thumbnail ${bookmarkData.thumbnail}:`, e);
                                        }
                                    }
                                } catch (e) {
                                    // JSON parse error, will be caught below
                                }
                            }

                            // Use generic loadCard function
                            const card = loadCard(filename, content, sectionName, companionData);
                            if (card) {
                                // Apply thumbnail from companion data if loaded
                                if (companionData.thumbnail) {
                                    card.thumbnail = companionData.thumbnail;
                                }
                                section.items.push(card);
                            }
                        } catch (e) {
                            console.error(`[Filesystem] Error reading ${filename}:`, e);
                        }
                    }

                    if (section.items.length > 0 || true) {  // Include empty sections too
                        loadedData.sections.push(section);
                    }
                }

                console.log(`[Filesystem] Loaded ${loadedData.sections.length} sections`);

                // Apply visibility from settings to loaded sections
                if (notebookSettings?.sections) {
                    for (const section of loadedData.sections) {
                        const sectionSlug = slugify(section.name);
                        const settingsRecord = notebookSettings.sections.find(s =>
                            (typeof s === 'string' ? s : s.name) === sectionSlug
                        );
                        if (settingsRecord && typeof settingsRecord === 'object') {
                            section.visible = settingsRecord.visible !== false;
                        }
                        // If not found in settings, default to visible (visible: true)
                    }
                }

                // Ensure _system section exists in settings if there are system notes
                if (loadedData.systemNotes && loadedData.systemNotes.length > 0) {
                    if (!notebookSettings.sections.some(s => (typeof s === 'string' ? s : s.name) === '_system')) {
                        // Add _system section (hidden by default)
                        notebookSettings.sections.push({ name: '_system', visible: false });
                        // Update settings card if it exists
                        const settingsCard = loadedData.systemNotes.find(n => n.template === 'settings');
                        if (settingsCard) {
                            settingsCard.sections = notebookSettings.sections;
                        }
                    }
                }

                // Create template files for card types that exist but don't have template files
                // This supports customization without auto-creating templates for empty types
                await ensureTemplatesForExistingCards(dirHandle, loadedData);

                return loadedData;

            } catch (error) {
                console.error('[Filesystem] Error loading from filesystem:', error);
                throw error;
            }
        }

        // Save notebook data to filesystem
        async function saveToFilesystem(dirHandle) {
            console.log('[Filesystem] Saving to directory...');

            try {
                // Update and save settings.yaml
                notebookSettings = {
                    notebook_title: data.title,
                    notebook_subtitle: data.subtitle,
                    sections: data.sections.map(s => ({ name: slugify(s.name), visible: s.visible !== false })),
                    extensions: notebookSettings?.extensions || getDefaultExtensionRegistry(),
                    theme: notebookSettings?.theme || null
                };
                await saveSettings(dirHandle);

                // Write README.md (only if it doesn't exist)
                try {
                    await dirHandle.getFileHandle('README.md');
                    // File exists, don't overwrite
                } catch (e) {
                    // File doesn't exist, create it
                    const readmeFile = await dirHandle.getFileHandle('README.md', { create: true });
                    const readmeWritable = await readmeFile.createWritable();
                    await readmeWritable.write(getReadmeTemplate(data.title));
                    await readmeWritable.close();
                }

                // Write CLAUDE.md (only if it doesn't exist)
                try {
                    await dirHandle.getFileHandle('CLAUDE.md');
                    // File exists, don't overwrite
                } catch (e) {
                    // File doesn't exist, create it
                    const claudeFile = await dirHandle.getFileHandle('CLAUDE.md', { create: true });
                    const claudeWritable = await claudeFile.createWritable();
                    await claudeWritable.write(getClaudeMdTemplate());
                    await claudeWritable.close();
                }

                // Create/get sections directory
                const sectionsDir = await dirHandle.getDirectoryHandle('sections', { create: true });

                // Create assets/thumbnails directory
                const assetsDir = await dirHandle.getDirectoryHandle('assets', { create: true });
                const thumbsDir = await assetsDir.getDirectoryHandle('thumbnails', { create: true });

                // Write each section
                for (const section of data.sections) {
                    const sectionSlug = slugify(section.name);
                    const sectionDir = await sectionsDir.getDirectoryHandle(sectionSlug, { create: true });

                    // Write section metadata
                    const sectionMetaFile = await sectionDir.getFileHandle('_section.json', { create: true });
                    const sectionMetaWritable = await sectionMetaFile.createWritable();
                    await sectionMetaWritable.write(JSON.stringify({
                        name: section.name,
                        id: section.id
                    }, null, 2));
                    await sectionMetaWritable.close();

                    // Write each item using generic serialization
                    for (const item of section.items) {
                        const titleSlug = slugify(item.title);
                        const { content, extension, format } = serializeCard(item);

                        // Special handling for bookmarks: save thumbnail to assets folder
                        if ((item.type === 'bookmark' || item.template === 'bookmark') && item.thumbnail && item.thumbnail.startsWith('data:')) {
                            const thumbFilename = `${item.id || titleSlug}.png`;
                            const thumbnailPath = `../../assets/thumbnails/${thumbFilename}`;

                            try {
                                const response = await fetch(item.thumbnail);
                                const blob = await response.blob();
                                const thumbHandle = await thumbsDir.getFileHandle(thumbFilename, { create: true });
                                const thumbWritable = await thumbHandle.createWritable();
                                await thumbWritable.write(blob);
                                await thumbWritable.close();

                                // Update content to use path instead of data URL
                                const bookmarkJson = JSON.parse(content);
                                bookmarkJson.thumbnail = thumbnailPath;
                                const updatedContent = JSON.stringify(bookmarkJson, null, 2);

                                const filename = `${titleSlug}${extension}`;
                                const fileHandle = await sectionDir.getFileHandle(filename, { create: true });
                                const writable = await fileHandle.createWritable();
                                await writable.write(updatedContent);
                                await writable.close();
                            } catch (e) {
                                console.error('[Filesystem] Error saving bookmark with thumbnail:', e);
                            }
                        } else {
                            // Write main card file
                            const filename = `${titleSlug}${extension}`;
                            const fileHandle = await sectionDir.getFileHandle(filename, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                        }

                        // Handle companion files based on extension registry
                        const extConfig = extensionRegistry[extension];
                        if (extConfig?.companionFiles) {
                            for (const companion of extConfig.companionFiles) {
                                const fieldValue = item[companion.field];
                                if (fieldValue) {
                                    const companionFilename = `${titleSlug}${companion.suffix}`;
                                    const companionHandle = await sectionDir.getFileHandle(companionFilename, { create: true });
                                    const companionWritable = await companionHandle.createWritable();
                                    await companionWritable.write(fieldValue);
                                    await companionWritable.close();
                                }
                            }
                        }
                    }
                }

                // Write system notes (text files at root)
                if (data.systemNotes) {
                    for (const note of data.systemNotes) {
                        // For raw text/yaml notes, preserve original filename
                        // For markdown notes, use title + .md
                        const newFilename = (note.format === 'text' || note.format === 'yaml') ? note.filename : (note.title + '.md');
                        const oldFilename = note.filename;

                        // If filename changed (markdown notes only), delete old file
                        if (oldFilename && oldFilename !== newFilename) {
                            try {
                                await dirHandle.removeEntry(oldFilename);
                                console.log(`[Filesystem] Deleted old system note: ${oldFilename}`);
                            } catch (e) {
                                // Old file might not exist
                            }
                        }

                        // Write with filename
                        const fileHandle = await dirHandle.getFileHandle(newFilename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(note.content);
                        await writable.close();

                        // Update filename in note object
                        note.filename = newFilename;
                        note.id = 'system-' + newFilename;
                    }
                }

                console.log('[Filesystem] Save complete');
            } catch (error) {
                console.error('[Filesystem] Error saving to filesystem:', error);
                throw error;
            }
        }

        // ========== Targeted filesystem save functions ==========
        // These functions save only specific files, avoiding full rewrites
        // Each records its save path so the observer can ignore our own writes

        // Track recent saves to ignore observer events for files we just wrote
        // Maps relative path -> timestamp
        let recentSaves = new Map();

        // Record that we just saved a file (path relative to notebook root)
        function recordSave(relativePath) {
            recentSaves.set(relativePath, Date.now());
            // Clean up old entries (older than 2s)
            const cutoff = Date.now() - 2000;
            for (const [path, time] of recentSaves) {
                if (time < cutoff) recentSaves.delete(path);
            }
        }

        // Check if we recently saved this file (within 1s)
        function wasRecentlySaved(relativePath) {
            const saveTime = recentSaves.get(relativePath);
            return saveTime && (Date.now() - saveTime < 1000);
        }

        // Save only settings.yaml (for settings, section order changes)
        async function saveNotebookMeta() {
            if (!filesystemLinked || !notebookDirHandle) return;

            // Update notebookSettings with current data
            notebookSettings = {
                notebook_title: data.title,
                notebook_subtitle: data.subtitle,
                sections: data.sections.map(s => ({ name: slugify(s.name), visible: s.visible !== false })),
                extensions: notebookSettings?.extensions || getDefaultExtensionRegistry(),
                theme: notebookSettings?.theme || null
            };
            await saveSettings(notebookDirHandle);
            recordSave('settings.yaml');
        }

        // Generic card save function using template system
        async function saveCardFile(sectionId, card) {
            if (!filesystemLinked || !notebookDirHandle) return;

            // Settings card is handled specially
            if (card.template === 'settings' || card.filename === 'settings.yaml') {
                // Update notebookSettings and data from the card fields
                notebookSettings = {
                    notebook_title: card.notebook_title || 'Research Notebook',
                    notebook_subtitle: card.notebook_subtitle || '',
                    sections: card.sections || notebookSettings?.sections || [],
                    extensions: card.extensions || notebookSettings?.extensions || getDefaultExtensionRegistry(),
                    theme: card.theme || null
                };
                // Also update data.title/subtitle so UI reflects changes
                data.title = notebookSettings.notebook_title;
                data.subtitle = notebookSettings.notebook_subtitle;
                // Update extension registry
                extensionRegistry = notebookSettings.extensions;

                // Reorder data.sections to match the new order from settings
                // card.sections is now an array of {name, visible} records
                if (card.sections && Array.isArray(card.sections)) {
                    const newOrder = [];
                    for (const sectionRecord of card.sections) {
                        const sectionName = typeof sectionRecord === 'string' ? sectionRecord : sectionRecord.name;
                        // Find section by matching slug
                        const section = data.sections.find(s => slugify(s.name) === sectionName);
                        if (section) {
                            // Apply visibility from settings record
                            if (typeof sectionRecord === 'object') {
                                section.visible = sectionRecord.visible !== false;
                            }
                            newOrder.push(section);
                        }
                    }
                    // Add any sections not in the list (shouldn't happen, but safety)
                    for (const section of data.sections) {
                        if (!newOrder.includes(section)) {
                            newOrder.push(section);
                        }
                    }
                    data.sections = newOrder;
                }

                await saveSettings(notebookDirHandle);
                card.filename = 'settings.yaml';
                card.id = 'system-settings.yaml';
                recordSave('settings.yaml');
                console.log('[Filesystem] Saved settings.yaml');
                return;
            }

            // Template cards are handled specially (serialized to YAML)
            if (card.template === 'template' || (card.filename && card.filename.endsWith('.template.yaml'))) {
                const filename = card.filename || (card.name + '.template.yaml');
                // Reconstruct the template object from card fields
                const templateObj = {
                    name: card.name,
                    description: card.description
                };
                if (card.schema && Object.keys(card.schema).length > 0) templateObj.schema = card.schema;
                if (card.card && Object.keys(card.card).length > 0) templateObj.card = card.card;
                if (card.viewer && Object.keys(card.viewer).length > 0) templateObj.viewer = card.viewer;
                if (card.editor && Object.keys(card.editor).length > 0) templateObj.editor = card.editor;
                if (card.style && Object.keys(card.style).length > 0) templateObj.style = card.style;
                if (card.ui && Object.keys(card.ui).length > 0) templateObj.ui = card.ui;

                const yamlContent = jsyaml.dump(templateObj, {
                    indent: 2,
                    lineWidth: -1,
                    quotingType: '"',
                    forceQuotes: false
                });

                const fileHandle = await notebookDirHandle.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(yamlContent);
                await writable.close();
                card.filename = filename;
                card.id = 'system-' + filename;

                // Reload the template into the registry
                const templateName = filename.replace(/\.template\.yaml$/, '');
                templateRegistry[templateName] = templateObj;

                recordSave(filename);
                console.log('[Filesystem] Saved template:', filename);
                return;
            }

            // Theme card is handled specially (saved as theme.css, reloads CSS)
            if (card.template === 'theme' || card.filename === 'theme.css') {
                const filename = 'theme.css';
                const fileHandle = await notebookDirHandle.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(card.content);
                await writable.close();
                card.filename = filename;
                card.id = 'system-theme.css';

                // Reload the theme CSS into the page
                await loadThemeCss(notebookDirHandle);

                recordSave(filename);
                console.log('[Filesystem] Saved and reloaded theme.css');
                return;
            }

            // System notes are handled specially (saved at root with raw content)
            if (sectionId === '_system' && card.system) {
                const filename = card.filename || (card.title + '.md');
                const fileHandle = await notebookDirHandle.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(card.content);
                await writable.close();
                card.filename = filename;
                card.id = 'system-' + filename;
                recordSave(filename);
                return;
            }

            const section = data.sections.find(s => s.id === sectionId);
            if (!section) return;

            const sectionsDir = await notebookDirHandle.getDirectoryHandle('sections', { create: true });
            const sectionSlug = slugify(section.name);
            const sectionDir = await sectionsDir.getDirectoryHandle(sectionSlug, { create: true });

            // Use serializeCard to get the file content and extension
            const { content, extension, format } = serializeCard(card);

            // Preserve original filename if card was loaded from filesystem
            // Otherwise derive from title (for new cards)
            let baseFilename;
            if (card._source?.filename) {
                // Strip extension from original filename to get base
                const origFilename = card._source.filename;
                if (origFilename.endsWith(extension)) {
                    baseFilename = origFilename.slice(0, -extension.length);
                } else {
                    // Extension changed or doesn't match - use original without any known extension
                    baseFilename = origFilename.replace(/\.(md|code\.py|bookmark\.json|card\.yaml)$/, '');
                }
            } else {
                baseFilename = slugify(card.title);
            }

            // Special handling for bookmarks: save thumbnail to assets folder
            if ((card.type === 'bookmark' || card.template === 'bookmark') && card.thumbnail && card.thumbnail.startsWith('data:')) {
                const assetsDir = await notebookDirHandle.getDirectoryHandle('assets', { create: true });
                const thumbsDir = await assetsDir.getDirectoryHandle('thumbnails', { create: true });
                const thumbFilename = `${card.id || baseFilename}.png`;
                const thumbnailPath = `../../assets/thumbnails/${thumbFilename}`;

                try {
                    const response = await fetch(card.thumbnail);
                    const blob = await response.blob();
                    const thumbHandle = await thumbsDir.getFileHandle(thumbFilename, { create: true });
                    const thumbWritable = await thumbHandle.createWritable();
                    await thumbWritable.write(blob);
                    await thumbWritable.close();
                    recordSave(`assets/thumbnails/${thumbFilename}`);

                    // Update the serialized content to use path instead of data URL
                    const bookmarkJson = JSON.parse(content);
                    bookmarkJson.thumbnail = thumbnailPath;
                    const updatedContent = JSON.stringify(bookmarkJson, null, 2);

                    const filename = `${baseFilename}${extension}`;
                    const fileHandle = await sectionDir.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(updatedContent);
                    await writable.close();
                    recordSave(`sections/${sectionSlug}/${filename}`);
                    return;
                } catch (e) {
                    console.error('[Filesystem] Error saving thumbnail:', e);
                }
            }

            // Write main card file
            const filename = `${baseFilename}${extension}`;
            const fileHandle = await sectionDir.getFileHandle(filename, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(content);
            await writable.close();
            recordSave(`sections/${sectionSlug}/${filename}`);

            // Handle companion files based on extension registry
            const extConfig = extensionRegistry[extension];
            if (extConfig?.companionFiles) {
                for (const companion of extConfig.companionFiles) {
                    const fieldValue = card[companion.field];
                    if (fieldValue) {
                        const companionFilename = `${baseFilename}${companion.suffix}`;
                        const companionHandle = await sectionDir.getFileHandle(companionFilename, { create: true });
                        const companionWritable = await companionHandle.createWritable();
                        await companionWritable.write(fieldValue);
                        await companionWritable.close();
                        recordSave(`sections/${sectionSlug}/${companionFilename}`);
                    }
                }
            }
        }

        // Create a new section directory with _section.json
        async function createSectionDir(section) {
            if (!filesystemLinked || !notebookDirHandle) return;

            const sectionsDir = await notebookDirHandle.getDirectoryHandle('sections', { create: true });
            const sectionSlug = slugify(section.name);
            const sectionDir = await sectionsDir.getDirectoryHandle(sectionSlug, { create: true });

            const sectionMetaFile = await sectionDir.getFileHandle('_section.json', { create: true });
            const sectionMetaWritable = await sectionMetaFile.createWritable();
            await sectionMetaWritable.write(JSON.stringify({
                name: section.name,
                id: section.id
            }, null, 2));
            await sectionMetaWritable.close();
            recordSave(`sections/${sectionSlug}/_section.json`);
        }

        // Delete a section directory
        async function deleteSectionDir(sectionName) {
            if (!filesystemLinked || !notebookDirHandle) return;

            try {
                const sectionsDir = await notebookDirHandle.getDirectoryHandle('sections');
                const sectionSlug = slugify(sectionName);
                await sectionsDir.removeEntry(sectionSlug, { recursive: true });
                // Record that we deleted files in this section (observer will see directory change)
                recordSave(`sections/${sectionSlug}`);
            } catch (e) {
                console.error('[Filesystem] Error deleting section dir:', e);
            }
        }

        // Delete a single item file
        async function deleteItemFile(sectionId, item) {
            if (!filesystemLinked || !notebookDirHandle) return;

            try {
                const section = data.sections.find(s => s.id === sectionId);
                if (!section) return;

                const sectionsDir = await notebookDirHandle.getDirectoryHandle('sections');
                const sectionSlug = slugify(section.name);
                const sectionDir = await sectionsDir.getDirectoryHandle(sectionSlug);

                // Support both legacy type field and new template field (Phase 3)
                const itemType = item.template || item.type;

                // Use stored _filename if available (from filesystem load), otherwise derive from title
                // This handles cases where filename doesn't match slugify(title)
                if (itemType === 'note') {
                    const filename = item._filename || `${slugify(item.title)}.md`;
                    await sectionDir.removeEntry(filename);
                    recordSave(`sections/${sectionSlug}/${filename}`);
                } else if (itemType === 'code') {
                    const baseFilename = item._filename || slugify(item.title);
                    const filename = `${baseFilename}.code.py`;
                    await sectionDir.removeEntry(filename);
                    recordSave(`sections/${sectionSlug}/${filename}`);
                    try {
                        const outputFilename = `${baseFilename}.output.html`;
                        await sectionDir.removeEntry(outputFilename);
                        recordSave(`sections/${sectionSlug}/${outputFilename}`);
                    } catch (e) { /* output might not exist */ }
                } else if (itemType === 'bookmark') {
                    const baseFilename = item._filename || slugify(item.title);
                    const filename = `${baseFilename}.bookmark.json`;
                    await sectionDir.removeEntry(filename);
                    recordSave(`sections/${sectionSlug}/${filename}`);
                }
            } catch (e) {
                console.error('[Filesystem] Error deleting item file:', e);
            }
        }

        // Rename a section directory
        async function renameSectionDir(oldName, newName, section) {
            if (!filesystemLinked || !notebookDirHandle) return;

            const oldSlug = slugify(oldName);
            const newSlug = slugify(newName);
            if (oldSlug === newSlug) return; // No actual rename needed

            try {
                const sectionsDir = await notebookDirHandle.getDirectoryHandle('sections');

                // Create new directory and copy files
                const oldDir = await sectionsDir.getDirectoryHandle(oldSlug);
                const newDir = await sectionsDir.getDirectoryHandle(newSlug, { create: true });

                // Copy all files from old to new
                for await (const [name, handle] of oldDir.entries()) {
                    if (handle.kind === 'file') {
                        const file = await handle.getFile();
                        const newFile = await newDir.getFileHandle(name, { create: true });
                        const writable = await newFile.createWritable();
                        await writable.write(await file.arrayBuffer());
                        await writable.close();
                        recordSave(`sections/${newSlug}/${name}`);
                    }
                }

                // Update _section.json with new name
                const sectionMetaFile = await newDir.getFileHandle('_section.json', { create: true });
                const sectionMetaWritable = await sectionMetaFile.createWritable();
                await sectionMetaWritable.write(JSON.stringify({
                    name: section.name,
                    id: section.id
                }, null, 2));
                await sectionMetaWritable.close();
                recordSave(`sections/${newSlug}/_section.json`);

                // Delete old directory
                await sectionsDir.removeEntry(oldSlug, { recursive: true });
                recordSave(`sections/${oldSlug}`);
            } catch (e) {
                console.error('[Filesystem] Error renaming section dir:', e);
            }
        }

        // Link a notebook folder - show picker and save handle
        async function linkNotebookFolder() {
            if (!isFileSystemAccessSupported()) {
                showToast(' File System Access not supported in this browser');
                return false;
            }

            try {
                // Show directory picker
                const handle = await window.showDirectoryPicker({
                    id: 'research-notebook',
                    mode: 'readwrite',
                    startIn: 'documents'
                });

                // Save handle for persistence
                await saveDirHandle(handle);
                notebookDirHandle = handle;
                filesystemLinked = true;

                // Check if directory has existing content
                let hasContent = false;
                try {
                    await handle.getDirectoryHandle('sections');
                    hasContent = true;
                } catch (e) {
                    // No sections directory
                }

                if (hasContent) {
                    // Load from filesystem
                    const fsData = await loadFromFilesystem(handle);
                    data = fsData;
                    render();
                    showToast(` Linked to folder (loaded ${data.sections.length} sections)`);
                } else {
                    // New notebook: create default section and all system files including templates
                    const defaultSection = {
                        id: 'section-' + Date.now(),
                        name: 'Research',
                        items: []
                    };
                    data.sections = [defaultSection];
                    data.systemNotes = [];  // Clear system notes from previous notebook
                    await saveToFilesystem(handle);
                    await createSectionDir(defaultSection);  // Create section directory
                    await ensureTemplateFiles(handle);  // Create template files for new notebooks
                    // Reload to pick up the newly created system notes
                    const fsData = await loadFromFilesystem(handle);
                    data = fsData;
                    render();
                    showToast(' Linked to folder (new notebook created)');
                }

                // Start watching for external changes
                await startWatchingFilesystem(handle);

                return true;

            } catch (error) {
                if (error.name === 'AbortError') {
                    // User cancelled picker
                    return false;
                }
                console.error('[Filesystem] Error linking folder:', error);
                showToast(' Error linking folder: ' + error.message);
                return false;
            }
        }

        // Unlink notebook folder
        async function unlinkNotebookFolder() {
            try {
                // Stop watching for changes
                stopWatchingFilesystem();

                const db = await openDB();
                const tx = db.transaction(IDB_STORE, 'readwrite');
                const store = tx.objectStore(IDB_STORE);
                store.delete(IDB_DIR_HANDLE_KEY);
                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });
                db.close();

                notebookDirHandle = null;
                filesystemLinked = false;
                showToast(' Switched to browser storage');
            } catch (error) {
                console.error('[Filesystem] Error unlinking folder:', error);
            }
        }

        // Initialize filesystem on page load (restore saved handle)
        async function initFilesystem() {
            if (!isFileSystemAccessSupported()) {
                console.log('[Filesystem] File System Access API not supported');
                return;
            }

            const savedHandle = await loadDirHandle();
            if (savedHandle) {
                const hasPermission = await verifyDirPermission(savedHandle);
                if (hasPermission) {
                    notebookDirHandle = savedHandle;
                    filesystemLinked = true;
                    console.log(`[Filesystem] Restored link to folder: ${savedHandle.name}`);

                    // Load data from filesystem
                    try {
                        const fsData = await loadFromFilesystem(savedHandle);
                        data = fsData;

                        // Start watching for external changes
                        await startWatchingFilesystem(savedHandle);
                    } catch (error) {
                        console.error('[Filesystem] Error loading from saved folder:', error);
                        showToast(' Error loading from linked folder');
                    }
                } else {
                    console.log('[Filesystem] Permission denied for saved folder');
                }
            }
        }

        // ========== SECTION: FILESYSTEM_OBSERVER ==========
        // FileSystemObserver for detecting external changes (Phase 2)
        // Functions: isFileSystemObserverSupported, startWatchingFilesystem, stopWatchingFilesystem,
        //            handleFilesystemChanges, reloadFromFilesystem

        // Check if FileSystemObserver API is available
        function isFileSystemObserverSupported() {
            return 'FileSystemObserver' in window;
        }

        // Start watching filesystem for external changes
        async function startWatchingFilesystem(dirHandle) {
            if (!isFileSystemObserverSupported()) {
                console.log('[Observer] FileSystemObserver not supported - manual refresh only');
                return false;
            }

            // Stop any existing observer
            stopWatchingFilesystem();

            try {
                filesystemObserver = new FileSystemObserver(handleFilesystemChanges);
                await filesystemObserver.observe(dirHandle, { recursive: true });
                console.log('[Observer] Started watching filesystem for changes');
                return true;
            } catch (error) {
                console.error('[Observer] Error starting filesystem observer:', error);
                filesystemObserver = null;
                return false;
            }
        }

        // Stop watching filesystem
        function stopWatchingFilesystem() {
            if (filesystemObserver) {
                filesystemObserver.disconnect();
                filesystemObserver = null;
                console.log('[Observer] Stopped watching filesystem');
            }
        }

        // Handle filesystem change events
        async function handleFilesystemChanges(records, observer) {
            // Ignore changes while reloading (prevents loops)
            if (isReloadingFromFilesystem) {
                console.log('[Observer] Ignoring changes during reload');
                return;
            }

            // Filter to relevant changes (ignore non-notebook files and files we recently saved)
            const relevantChanges = records.filter(record => {
                const pathComponents = record.relativePathComponents || [];
                const relativePath = pathComponents.join('/');
                const filename = pathComponents[pathComponents.length - 1] || '';

                // Skip files we recently saved (our own writes echoing back)
                if (wasRecentlySaved(relativePath)) {
                    console.log(`[Observer] Ignoring recently saved: ${relativePath}`);
                    return false;
                }

                // Relevant: .md, .code.py, .bookmark.json, settings.yaml, _section.json, .output.html
                // Also include directory changes (for new sections)
                if (record.changedHandle?.kind === 'directory') return true;
                if (filename.endsWith('.md')) return true;
                if (filename.endsWith('.code.py')) return true;
                if (filename.endsWith('.output.html')) return true;
                if (filename.endsWith('.bookmark.json')) return true;
                if (filename === 'settings.yaml') return true;
                if (filename === 'notebook.json') return true;  // Legacy
                if (filename === '_section.json') return true;
                return false;
            });

            if (relevantChanges.length === 0) {
                console.log('[Observer] No relevant changes detected');
                return;
            }

            // Log what changed for debugging
            console.log(`[Observer] Detected ${relevantChanges.length} relevant changes:`);
            relevantChanges.forEach(record => {
                const path = (record.relativePathComponents || []).join('/');
                console.log(`  - ${record.type}: ${path || record.changedHandle?.name || 'unknown'}`);
            });

            // Reload from filesystem
            await reloadFromFilesystem();
        }

        // Reload notebook data from filesystem (called by observer or manual refresh)
        // showNotification: if true, shows toast for external sync (used by observer)
        async function reloadFromFilesystem(showNotification = true) {
            if (!filesystemLinked || !notebookDirHandle) {
                console.log('[Observer] Cannot reload - no folder linked');
                return;
            }

            isReloadingFromFilesystem = true;

            try {
                console.log('[Observer] Reloading from filesystem...');
                const fsData = await loadFromFilesystem(notebookDirHandle);
                data = fsData;
                render();
                if (showNotification) {
                    showToast(' Synced external changes');
                }
                console.log('[Observer] Reload complete');
            } catch (error) {
                console.error('[Observer] Error reloading from filesystem:', error);
                if (showNotification) {
                    showToast(' Error syncing changes');
                }
                throw error;  // Re-throw so caller can handle
            } finally {
                isReloadingFromFilesystem = false;
            }
        }

        // ========== SECTION: UI_UTILITIES ==========
        // Toast notifications and misc UI helpers

        // Show toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('active');
            setTimeout(() => toast.classList.remove('active'), 3000);
        }

        // ========== SECTION: SECTION_MODAL ==========
        // Section creation modal: open, close, create

        // Section Modal
        function openSectionModal() {
            document.getElementById('sectionModal').classList.add('active');
            document.getElementById('sectionName').focus();
        }

        function closeSectionModal() {
            document.getElementById('sectionModal').classList.remove('active');
            document.getElementById('sectionName').value = '';
        }

        async function createSection() {
            const name = document.getElementById('sectionName').value.trim();
            if (!name) {
                showToast('Please enter a section name');
                return;
            }

            const section = {
                id: Date.now().toString(),
                name: name,
                items: []
            };
            data.sections.push(section);

            await saveData();
            await saveNotebookMeta();  // Update settings.yaml with new section list
            await createSectionDir(section);  // Create section directory
            render();
            closeSectionModal();
            showToast('Section created');
        }

        // ========== SECTION: SETTINGS_MODAL ==========
        // Settings are now handled via the settings.yaml system card
        // Storage settings: refreshFromFilesystem, changeNotebookFolder

        // Open settings editor (template-based approach)
        // This opens the generic editor for the settings.yaml system card
        function openSettingsEditor() {
            // Find the settings card in systemNotes
            let settingsCard = data.systemNotes?.find(n => n.template === 'settings' || n.filename === 'settings.yaml');

            // If no settings card exists, create one with current values
            if (!settingsCard) {
                settingsCard = {
                    template: 'settings',
                    system: true,
                    id: 'system-settings.yaml',
                    filename: 'settings.yaml',
                    title: 'Settings',
                    notebook_title: data.title || 'Research Notebook',
                    notebook_subtitle: data.subtitle || '',
                    sections: data.sections.map(s => ({ name: slugify(s.name), visible: s.visible !== false })),
                    extensions: notebookSettings?.extensions || getDefaultExtensionRegistry(),
                    theme: notebookSettings?.theme || null,
                    modified: new Date().toISOString()
                };
                // Add to systemNotes so it appears in the list
                if (!data.systemNotes) data.systemNotes = [];
                data.systemNotes.unshift(settingsCard);
            }

            // Open the generic editor with the settings card
            openEditor('settings', '_system', settingsCard);
        }

        // Change to a different notebook folder
        async function changeNotebookFolder() {
            const success = await linkNotebookFolder();
            if (success) {
                closeEditor();  // Close settings editor if open
                render();
            }
        }

        // Refresh data from filesystem
        async function refreshFromFilesystem() {
            if (!filesystemLinked || !notebookDirHandle) {
                showToast(' No folder linked');
                return;
            }

            try {
                showToast(' Refreshing from folder...');
                await reloadFromFilesystem(false);  // Don't show auto-sync toast
                showToast(` Refreshed (${data.sections.length} sections)`);
            } catch (error) {
                console.error('[Filesystem] Refresh error:', error);
                showToast(' Error refreshing: ' + error.message);
            }
        }

        // ========== SECTION: ONBOARDING ==========
        // First-time setup flow for new notebooks

        // Show onboarding modal
        function showOnboarding() {
            // Check browser support
            if (!isFileSystemAccessSupported()) {
                document.getElementById('onboardingUnsupported').style.display = 'block';
            }
            document.getElementById('onboardingModal').classList.add('active');
        }

        // Close onboarding modal
        function closeOnboarding() {
            document.getElementById('onboardingModal').classList.remove('active');
        }

        // Setup notebook folder from onboarding
        async function setupNotebookFolder() {
            const success = await linkNotebookFolder();
            if (success) {
                closeOnboarding();
                render();
            }
        }

        // ========== SECTION: PYODIDE_RUNTIME ==========
        // Python execution via Pyodide: initPyodide, updatePyodideStatus, runCode, executePythonCode
        // Config: Pyodide v0.28.2 from jsDelivr CDN, pre-loads numpy/pandas/matplotlib, 120s timeout
        // IMPORTANT: initPyodide() not loadPyodide() to avoid collision with window.loadPyodide

        // Load Pyodide lazily
        async function initPyodide() {
            if (pyodideReady) return pyodide;
            if (pyodideLoading) {
                // Wait for existing load to complete
                while (pyodideLoading) {
                    await new Promise(r => setTimeout(r, 100));
                }
                return pyodide;
            }

            pyodideLoading = true;
            updatePyodideStatus('loading', 'Initializing Python runtime...');
            console.log('[Pyodide] Starting to initialize Pyodide runtime...');

            try {
                // Check if loadPyodide is available
                if (!window.loadPyodide) {
                    throw new Error('Pyodide script not loaded. Please refresh the page.');
                }

                console.log('[Pyodide] Calling window.loadPyodide...');
                const startTime = Date.now();

                // Add timeout wrapper to prevent infinite hanging (120 seconds for slow connections)
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Pyodide initialization timed out after 120 seconds. Please check your internet connection.')), 120000);
                });

                pyodide = await Promise.race([
                    window.loadPyodide({
                        indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.28.2/full/',
                        stdout: console.log,
                        stderr: console.error
                    }),
                    timeoutPromise
                ]);

                const loadTime = ((Date.now() - startTime) / 1000).toFixed(2);
                console.log(`[Pyodide] Runtime initialized successfully in ${loadTime}s`);

                // Load common packages
                console.log('[Pyodide] Loading numpy, pandas, matplotlib...');
                updatePyodideStatus('loading', 'Loading Python packages...');
                const pkgStart = Date.now();

                await pyodide.loadPackage(['numpy', 'pandas', 'matplotlib']);

                const pkgTime = ((Date.now() - pkgStart) / 1000).toFixed(2);
                console.log(`[Pyodide] Packages loaded in ${pkgTime}s`);

                // Set up Python environment
                console.log('[Pyodide] Setting up Python environment...');
                updatePyodideStatus('loading', 'Setting up Python environment...');
                await pyodide.runPythonAsync(`
import sys
import io
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt

# Helper function for matplotlib plots
def _get_plot_as_base64():
    import base64
    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    img_base64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close('all')
    return img_base64
                `);

                pyodideReady = true;
                pyodideLoading = false;
                updatePyodideStatus('ready', 'Python ready');
                console.log('[Pyodide] Ready to execute Python code');
                console.log('[Pyodide] Available packages: numpy, pandas, matplotlib');
                return pyodide;
            } catch (error) {
                console.error('[Pyodide] Load failed:', error);
                pyodideLoading = false;
                updatePyodideStatus('error', 'Failed to load Python: ' + error.message);
                throw error;
            }
        }

        function updatePyodideStatus(state, message) {
            const statusEl = document.getElementById('pyodideStatus');
            if (!statusEl) return;
            
            statusEl.className = 'pyodide-status ' + state;
            if (state === 'loading') {
                statusEl.innerHTML = `<span class="spinner-small"></span> ${message}`;
            } else {
                statusEl.textContent = message;
            }
        }

        // Run Python code
        async function runCode() {
            const code = document.getElementById('codeContent').value;
            const outputEl = document.getElementById('codeOutput');
            const runBtn = document.getElementById('runCodeBtn');

            if (!code.trim()) {
                outputEl.innerHTML = '<span class="error">No code to run</span>';
                return;
            }

            runBtn.disabled = true;
            runBtn.textContent = ' Running...';
            outputEl.innerHTML = '<span style="color: var(--text-muted);">Running...</span>';

            try {
                const py = await initPyodide();
                const result = await executePythonCode(py, code);
                outputEl.innerHTML = result;
            } catch (error) {
                outputEl.innerHTML = `<pre class="error">${escapeHtml(error.toString())}</pre>`;
            } finally {
                runBtn.disabled = false;
                runBtn.textContent = ' Run';
            }
        }

        async function executePythonCode(py, code) {
            let output = '';

            // Capture stdout
            await py.runPythonAsync(`
import sys
from io import StringIO
_stdout_capture = StringIO()
_stderr_capture = StringIO()
sys.stdout = _stdout_capture
sys.stderr = _stderr_capture
            `);

            try {
                // Run the user's code
                const result = await py.runPythonAsync(code);

                // Get captured output
                const stdout = await py.runPythonAsync('_stdout_capture.getvalue()');
                const stderr = await py.runPythonAsync('_stderr_capture.getvalue()');

                // Check for matplotlib figures
                let hasFigure = false;
                try {
                    hasFigure = await py.runPythonAsync(`len(plt.get_fignums()) > 0`);
                } catch (e) {
                    // matplotlib not available or error, skip figure checking
                }

                // Show stdout
                if (stdout) {
                    output += `<pre>${escapeHtml(stdout)}</pre>`;
                }

                // Show stderr
                if (stderr) {
                    output += `<pre class="stderr">${escapeHtml(stderr)}</pre>`;
                }

                // Show matplotlib plots
                if (hasFigure) {
                    const imgBase64 = await py.runPythonAsync('_get_plot_as_base64()');
                    output += `<img src="data:image/png;base64,${imgBase64}" alt="Plot">`;
                }

                // Check if last line result is a DataFrame
                if (result && !hasFigure) {
                    try {
                        const isDataFrame = await py.runPythonAsync(`
import pandas as pd
isinstance(${code.trim().split('\n').pop()}, pd.DataFrame) if '${code.trim().split('\n').pop()}' else False
                        `).catch(() => false);

                        if (isDataFrame) {
                            const html = await py.runPythonAsync(`${code.trim().split('\n').pop()}.to_html(max_rows=20)`);
                            output += html;
                        }
                    } catch (e) {
                        // Not a DataFrame or error
                    }
                }

                // Show return value only if:
                // - There's a result
                // - No matplotlib figure was created
                // - No other output was generated
                // - Result is not a matplotlib object
                if (result !== undefined && result !== null && !output && !hasFigure) {
                    const resultStr = result.toString();
                    // Don't show matplotlib objects
                    if (resultStr &&
                        resultStr !== 'undefined' &&
                        !resultStr.includes('matplotlib') &&
                        !resultStr.includes('<') &&
                        !resultStr.includes('object at 0x')) {
                        output += `<pre>${escapeHtml(resultStr)}</pre>`;
                    }
                }

                if (!output) {
                    output = '<span style="color: var(--text-muted);">Code executed successfully (no output)</span>';
                }

            } catch (error) {
                output = `<pre class="error">${escapeHtml(error.toString())}</pre>`;
            } finally {
                // Reset stdout/stderr
                await py.runPythonAsync(`
sys.stdout = sys.__stdout__
sys.stderr = sys.__stderr__
                `);
            }

            return output;
        }

        // ========== SECTION: INTERNAL_LINKING ==========
        // Wiki-style [[links]]: renderMarkdownWithLinks, renderNotePreview, resolveLink, findBacklinks, navigateToItem

        // Internal linking
        function renderMarkdownWithLinks(text, containerId = null) {
            if (!text) return '';
            
            // Store all special elements to protect from markdown processing
            const protectedBlocks = [];
            let processed = text;
            
            // Protect display math $$...$$ 
            processed = processed.replace(/\$\$([^$]+)\$\$/g, (match, latex) => {
                protectedBlocks.push({ type: 'displaymath', content: latex });
                return `%%PROTECTED_${protectedBlocks.length - 1}%%`;
            });
            
            // Protect inline math $...$
            processed = processed.replace(/\$([^$\n]+)\$/g, (match, latex) => {
                protectedBlocks.push({ type: 'inlinemath', content: latex });
                return `%%PROTECTED_${protectedBlocks.length - 1}%%`;
            });
            
            // Protect internal links [[Title]] or [[id:xyz]]
            const linkPattern = /\[\[([^\]]+)\]\]/g;
            processed = processed.replace(linkPattern, (match, linkText) => {
                const target = resolveLink(linkText);
                if (target) {
                    protectedBlocks.push({ 
                        type: 'link', 
                        sectionId: target.sectionId, 
                        itemId: target.id, 
                        title: target.title 
                    });
                } else {
                    protectedBlocks.push({ 
                        type: 'brokenlink', 
                        text: linkText 
                    });
                }
                return `%%PROTECTED_${protectedBlocks.length - 1}%%`;
            });
            
            // Render markdown
            let html = marked.parse(processed);
            
            // Restore protected blocks
            html = html.replace(/%%PROTECTED_(\d+)%%/g, (match, index) => {
                const block = protectedBlocks[parseInt(index)];
                switch (block.type) {
                    case 'displaymath':
                        try {
                            return katex.renderToString(block.content, {
                                displayMode: true,
                                throwOnError: false
                            });
                        } catch (e) {
                            return `<span style="color: var(--accent);">${escapeHtml(block.content)}</span>`;
                        }
                    case 'inlinemath':
                        try {
                            return katex.renderToString(block.content, {
                                displayMode: false,
                                throwOnError: false
                            });
                        } catch (e) {
                            return `<span style="color: var(--accent);">${escapeHtml(block.content)}</span>`;
                        }
                    case 'link':
                        return `<span class="internal-link" data-link-section="${block.sectionId}" data-link-item="${block.itemId}">${escapeHtml(block.title)}</span>`;
                    case 'brokenlink':
                        return `<span class="internal-link broken" title="Link not found">${escapeHtml(block.text)}</span>`;
                    default:
                        return match;
                }
            });
            
            return html;
        }

        // Render preview for note cards (truncated, with clickable links)
        function renderNotePreview(text, format = 'markdown', maxLength = 1200) {
            if (!text) return '';

            // For raw text or yaml format, just escape and truncate
            if (format === 'text' || format === 'yaml') {
                let truncated = text;
                if (text.length > maxLength) {
                    truncated = text.substring(0, maxLength);
                    const lastNewline = truncated.lastIndexOf('\n');
                    if (lastNewline > maxLength * 0.5) {
                        truncated = truncated.substring(0, lastNewline);
                    }
                    truncated += '...';
                }
                return `<pre style="margin: 0; white-space: pre-wrap; font-size: 0.75rem; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;">${escapeHtml(truncated)}</pre>`;
            }

            // Collapse multiple newlines for cleaner preview
            let cleaned = text.replace(/\n{3,}/g, '\n\n').trim();

            // Truncate text for performance
            let truncated = cleaned;
            if (cleaned.length > maxLength) {
                truncated = cleaned.substring(0, maxLength);
                // Try to break at a word boundary
                const lastSpace = truncated.lastIndexOf(' ');
                if (lastSpace > maxLength * 0.7) {
                    truncated = truncated.substring(0, lastSpace);
                }
                truncated += '...';
            }

            return renderMarkdownWithLinks(truncated);
        }

        function resolveLink(linkText) {
            // Check if it's an ID link: [[id:abc123]]
            if (linkText.startsWith('id:')) {
                const id = linkText.substring(3);
                for (const section of data.sections) {
                    const item = section.items.find(i => i.id === id);
                    if (item) {
                        return { ...item, sectionId: section.id };
                    }
                }
                return null;
            }

            // Check for section-scoped link: [[Section > Card title]]
            const scopedMatch = linkText.match(/^(.+?)\s*>\s*(.+)$/);
            if (scopedMatch) {
                const sectionName = scopedMatch[1].trim().toLowerCase();
                const cardTitle = scopedMatch[2].trim().toLowerCase();
                const section = data.sections.find(s => s.name && s.name.toLowerCase() === sectionName);
                if (section) {
                    const item = section.items.find(i => i.title && i.title.toLowerCase() === cardTitle);
                    if (item) {
                        return { ...item, sectionId: section.id };
                    }
                }
                return null;
            }

            // Otherwise search by title across all sections (case-insensitive)
            const searchTitle = linkText.toLowerCase();
            for (const section of data.sections) {
                const item = section.items.find(i => i.title && i.title.toLowerCase() === searchTitle);
                if (item) {
                    return { ...item, sectionId: section.id };
                }
            }
            return null;
        }

        function findBacklinks(itemId) {
            const backlinks = [];

            // Get the target item's title and section
            let targetTitle = null;
            let targetSectionName = null;
            for (const section of data.sections) {
                const item = section.items.find(i => i.id === itemId);
                if (item && item.title) {
                    targetTitle = item.title.toLowerCase();
                    targetSectionName = section.name ? section.name.toLowerCase() : null;
                    break;
                }
            }

            for (const section of data.sections) {
                for (const item of section.items) {
                    if (item.id === itemId) continue;

                    const content = item.type === 'note' ? item.content : item.description;
                    if (!content) continue;

                    // Check for ID link
                    if (content.includes(`[[id:${itemId}]]`)) {
                        backlinks.push({ ...item, sectionId: section.id });
                        continue;
                    }

                    // Check for title link (plain or section-scoped)
                    if (targetTitle) {
                        const matches = content.matchAll(/\[\[([^\]]+)\]\]/g);
                        for (const match of matches) {
                            const linkText = match[1];
                            // Check for section-scoped link: [[Section > Card title]]
                            const scopedMatch = linkText.match(/^(.+?)\s*>\s*(.+)$/);
                            if (scopedMatch) {
                                const sectionName = scopedMatch[1].trim().toLowerCase();
                                const cardTitle = scopedMatch[2].trim().toLowerCase();
                                if (cardTitle === targetTitle && targetSectionName && sectionName === targetSectionName) {
                                    backlinks.push({ ...item, sectionId: section.id });
                                    break;
                                }
                            } else if (linkText.toLowerCase() === targetTitle) {
                                // Plain title link
                                backlinks.push({ ...item, sectionId: section.id });
                                break;
                            }
                        }
                    }
                }
            }

            return backlinks;
        }

        function navigateToItem(sectionId, itemId) {
            // Close current viewer and open target
            closeViewer();
            openViewer(sectionId, itemId);
        }

        // ========== SECTION: THUMBNAIL_GENERATION ==========
        // Auto-thumbnail via microlink API and PDF.js: resizeAndCompressThumbnail, urlToDataUrl, generateThumbnail, generatePdfThumbnail, extractDomain

        // Helper function to resize and compress a canvas or image to reduce storage size
        // Target: 1000px width for high quality display, JPEG 90% quality
        async function resizeAndCompressThumbnail(source, maxWidth = 1000, quality = 0.90) {
            try {
                // Create an image element from the source
                let img;
                if (source instanceof HTMLCanvasElement) {
                    // If source is a canvas, convert to image
                    img = new Image();
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = source.toDataURL('image/jpeg', 0.95);
                    });
                } else if (typeof source === 'string') {
                    // If source is a data URL string
                    img = new Image();
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = source;
                    });
                } else if (source instanceof Blob) {
                    // If source is a blob
                    img = new Image();
                    const url = URL.createObjectURL(source);
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            URL.revokeObjectURL(url);
                            resolve();
                        };
                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            reject();
                        };
                        img.src = url;
                    });
                } else {
                    throw new Error('Unsupported source type');
                }

                // Calculate new dimensions maintaining aspect ratio
                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height = (height * maxWidth) / width;
                    width = maxWidth;
                }

                // Create a new canvas with target dimensions
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Draw image to canvas (browser does high-quality downsampling)
                ctx.drawImage(img, 0, 0, width, height);

                // Convert to data URL with compression
                return canvas.toDataURL('image/jpeg', quality);
            } catch (error) {
                console.log('Failed to resize thumbnail:', error);
                return null;
            }
        }

        // Helper function to convert remote image URL to data URL for offline storage
        async function urlToDataUrl(imageUrl) {
            try {
                const response = await fetch(imageUrl);
                if (!response.ok) throw new Error('Failed to fetch image');

                const blob = await response.blob();

                // Resize and compress the image before storing
                return await resizeAndCompressThumbnail(blob);
            } catch (error) {
                console.log('Failed to convert URL to data URL:', error);
                return null;
            }
        }

        // Generate thumbnail using a service or PDF.js for PDFs
        async function generateThumbnail(url) {
            try {
                // Check if it's a PDF
                const isPdf = url.toLowerCase().endsWith('.pdf') ||
                              url.toLowerCase().includes('/pdf/') ||
                              url.toLowerCase().includes('arxiv.org/pdf');

                if (isPdf) {
                    return await generatePdfThumbnail(url);
                }

                // For regular pages, use microlink
                const encodedUrl = encodeURIComponent(url);
                const apiUrl = `https://api.microlink.io/?url=${encodedUrl}&screenshot=true&meta=false`;
                const response = await fetch(apiUrl);
                const json = await response.json();

                // Extract screenshot URL from the response
                if (json.status === 'success' && json.data?.screenshot?.url) {
                    // Convert remote URL to data URL for offline access
                    return await urlToDataUrl(json.data.screenshot.url);
                }

                return null;
            } catch {
                return null;
            }
        }

        // Generate thumbnail from PDF first page using PDF.js
        async function generatePdfThumbnail(url) {
            try {
                // Set worker source
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                
                // Load the PDF
                const loadingTask = pdfjsLib.getDocument({
                    url: url,
                });
                
                const pdf = await loadingTask.promise;
                const page = await pdf.getPage(1);
                
                // Set scale for good quality
                const scale = 2;
                const viewport = page.getViewport({ scale });
                
                // Create canvas for full page render
                const fullCanvas = document.createElement('canvas');
                const fullContext = fullCanvas.getContext('2d');
                fullCanvas.width = viewport.width;
                fullCanvas.height = viewport.height;
                
                // Render page to canvas
                await page.render({
                    canvasContext: fullContext,
                    viewport: viewport
                }).promise;
                
                // Create a cropped canvas with just the top 45% of the page
                const cropRatio = 0.45;
                const croppedCanvas = document.createElement('canvas');
                const croppedContext = croppedCanvas.getContext('2d');
                croppedCanvas.width = viewport.width;
                croppedCanvas.height = viewport.height * cropRatio;
                
                // Copy top portion from full canvas to cropped canvas
                croppedContext.drawImage(
                    fullCanvas,
                    0, 0, viewport.width, viewport.height * cropRatio,
                    0, 0, viewport.width, viewport.height * cropRatio
                );

                // Resize and compress before returning
                return await resizeAndCompressThumbnail(croppedCanvas);
            } catch (error) {
                console.log('PDF thumbnail failed, using fallback:', error.message);
                // Fallback to microlink for PDFs that can't be loaded directly (CORS issues)
                const encodedUrl = encodeURIComponent(url);
                const apiUrl = `https://api.microlink.io/?url=${encodedUrl}&screenshot=true&meta=false`;
                const response = await fetch(apiUrl);
                const json = await response.json();
                // Convert remote URL to data URL for offline access
                return json.status === 'success' && json.data?.screenshot?.url
                    ? await urlToDataUrl(json.data.screenshot.url)
                    : null;
            }
        }

        function extractDomain(url) {
            try {
                return new URL(url).hostname.replace('www.', '');
            } catch {
                return url;
            }
        }

        // ========== SECTION: DATA_OPERATIONS ==========
        // Section/item actions: toggleSection, toggleCodeOutput, confirmDeleteItem, deleteSection, deleteItem, updateSectionName

        // Toggle section collapsed state
        function toggleSection(sectionId) {
            if (collapsedSections.has(sectionId)) {
                collapsedSections.delete(sectionId);
            } else {
                collapsedSections.add(sectionId);
            }
            saveCollapsedSections();
            render();
        }

        async function toggleCodeOutput(sectionId, codeId) {
            const section = data.sections.find(s => s.id === sectionId);
            if (!section) return;
            const codeNote = section.items.find(item => item.id === codeId && item.type === 'code');
            if (!codeNote) return;

            codeNote.showOutput = !codeNote.showOutput;
            await saveData();
            await saveCardFile(sectionId, codeNote);  // Save code file with updated showOutput
            render();
        }

        // Confirm before deleting item
        function confirmDeleteItem(sectionId, itemId, itemType) {
            if (confirm(`Delete this ${itemType}?`)) {
                deleteItem(sectionId, itemId);
            }
        }

        // Delete section
        async function deleteSection(sectionId) {
            if (!confirm('Delete this section?')) return;
            const section = data.sections.find(s => s.id === sectionId);
            const sectionName = section?.name;
            data.sections = data.sections.filter(s => s.id !== sectionId);
            await saveData();
            await saveNotebookMeta();  // Update settings.yaml
            if (sectionName) await deleteSectionDir(sectionName);  // Delete section directory
            render();
            showToast('Section deleted');
        }

        // Delete item
        async function deleteItem(sectionId, itemId) {
            const section = data.sections.find(s => s.id === sectionId);
            if (!section) return;
            const item = section.items.find(i => i.id === itemId);
            section.items = section.items.filter(i => i.id !== itemId);
            await saveData();
            if (item) await deleteItemFile(sectionId, item);  // Delete specific file
            render();
            showToast('Item deleted');
        }

        // Update section name
        async function updateSectionName(sectionId, newName) {
            const section = data.sections.find(s => s.id === sectionId);
            if (section && newName.trim()) {
                const oldName = section.name;
                section.name = newName.trim();
                await saveData();
                await saveNotebookMeta();  // Update settings.yaml with new section list
                await renameSectionDir(oldName, newName.trim(), section);  // Rename directory
            }
        }

        // ========== SECTION: UTILITY_FUNCTIONS ==========
        // Misc utility functions

        // Deep merge objects (target values override source, but missing keys filled from source)
        // Used for merging user template overrides with built-in defaults
        function deepMerge(source, target) {
            if (!target) return source;
            if (!source) return target;
            if (typeof source !== 'object' || typeof target !== 'object') return target;
            if (Array.isArray(source) || Array.isArray(target)) return target;

            const result = { ...source };
            for (const key of Object.keys(target)) {
                if (typeof target[key] === 'object' && target[key] !== null && !Array.isArray(target[key]) &&
                    typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
                    result[key] = deepMerge(source[key], target[key]);
                } else {
                    result[key] = target[key];
                }
            }
            return result;
        }

        // Generate unique ID
        function generateId() {
            return Date.now().toString() + Math.random().toString(36).substr(2, 9);
        }

        // Format date
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
            });
        }

        // Get plain text preview from markdown
        function getPlainTextPreview(markdown, maxLength = 200) {
            if (!markdown) return '';
            // Remove markdown syntax
            let text = markdown
                .replace(/\[\[([^\]]+)\]\]/g, '$1') // Internal links
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // External links
                .replace(/[#*_`~]/g, '') // Headers, bold, italic, code
                .replace(/\n+/g, ' ') // Newlines
                .trim();
            if (text.length > maxLength) {
                text = text.substring(0, maxLength) + '...';
            }
            return text;
        }

        // ========== SECTION: RENDER_FUNCTIONS ==========
        // Main render and template buttons: render, renderTemplateButtons, findNote, findCode, escapeHtml
        // Note: Generic renderCard() and openViewer() are in TEMPLATE_SYSTEM section

        // Generate template-driven "New X" buttons for a section
        function renderTemplateButtons(sectionId) {
            // Get templates sorted by sort_order
            const templates = Object.values(templateRegistry)
                .filter(t => t.ui?.show_create_button !== false)
                .sort((a, b) => (a.ui?.sort_order || 99) - (b.ui?.sort_order || 99));

            // Button styles by template type
            const buttonStyles = {
                note: 'btn-note',
                code: 'btn-code',
                bookmark: 'btn-secondary'
            };

            return templates.map(t => {
                // Use generic editor (Phase 3)
                const opener = `openEditor('${t.name}', '${sectionId}')`;
                const style = buttonStyles[t.name] || 'btn-secondary';
                const label = t.ui?.button_label || t.name;
                const icon = t.ui?.icon || '';
                return `<button class="btn ${style} btn-small" onclick="${opener}">
                    ${icon ? icon + ' ' : '+ '}${label}
                </button>`;
            }).join('');
        }

        // Render the UI
        function render() {
            // Update header and page title with current title and subtitle
            const title = data.title || 'Research Notebook';
            document.getElementById('headerTitle').textContent = title;
            document.getElementById('headerSubtitle').textContent = data.subtitle || 'Bookmarks, notes, and connections';
            document.title = title;

            const content = document.getElementById('content');

            // Filter sections by visibility
            const visibleSections = data.sections.filter(s => s.visible !== false);

            // Check if _system section is visible (from settings)
            const systemSectionVisible = getSystemSectionVisible();
            const hasSystemNotes = systemSectionVisible && data.systemNotes && data.systemNotes.length > 0;

            if (visibleSections.length === 0 && !hasSystemNotes) {
                content.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"></div>
                        <h2>Your research notebook awaits</h2>
                        <p>Create a section to start organizing your bookmarks and notes</p>
                    </div>
                `;
                return;
            }

            let sectionsHtml = visibleSections.map(section => {
                const isCollapsed = collapsedSections.has(section.id);
                const itemCount = section.items.length;

                return `
                <div class="section" data-section-id="${section.id}">
                    ${itemCount === 0 ? `<button class="section-delete" onclick="deleteSection('${section.id}')" title="Delete empty section"></button>` : ''}
                    <div class="section-header">
                        <button class="section-toggle ${isCollapsed ? 'collapsed' : ''}" onclick="toggleSection('${section.id}')" title="${isCollapsed ? 'Expand' : 'Collapse'}"></button>
                        <h2 class="section-title">
                            <input type="text" value="${escapeHtml(section.name)}"
                                onchange="updateSectionName('${section.id}', this.value)"
                                onblur="updateSectionName('${section.id}', this.value)">
                            ${isCollapsed && itemCount > 0 ? `<span class="section-count">(${itemCount})</span>` : ''}
                        </h2>
                        <div class="section-actions">
                            ${renderTemplateButtons(section.id)}
                        </div>
                    </div>
                    <div class="items-grid ${isCollapsed ? 'collapsed' : ''}">
                        ${itemCount === 0 ?
                            '<p style="color: var(--text-muted); grid-column: 1/-1;">No items yet. Add a bookmark, note, or code!</p>' :
                            [...section.items].sort((a, b) => {
                                // Sort by modified time descending (most recent first)
                                const aTime = a.modified ? new Date(a.modified).getTime() : 0;
                                const bTime = b.modified ? new Date(b.modified).getTime() : 0;
                                return bTime - aTime;
                            }).map(item => renderCard(section.id, item)).join('')
                        }
                    </div>
                </div>
            `}).join('');

            // Add System section if enabled and has notes
            if (hasSystemNotes) {
                const isCollapsed = collapsedSections.has('_system');
                const itemCount = data.systemNotes.length;

                sectionsHtml += `
                <div class="section section-system" data-section-id="_system">
                    <div class="section-header">
                        <button class="section-toggle ${isCollapsed ? 'collapsed' : ''}" onclick="toggleSection('_system')" title="${isCollapsed ? 'Expand' : 'Collapse'}"></button>
                        <h2 class="section-title">
                            <span style="color: var(--text-muted);">System</span>
                            ${isCollapsed && itemCount > 0 ? `<span class="section-count">(${itemCount})</span>` : ''}
                        </h2>
                        <div class="section-actions">
                            <button class="btn btn-note btn-small" onclick="openEditor('note', '_system')">
                                + Note
                            </button>
                        </div>
                    </div>
                    <div class="items-grid ${isCollapsed ? 'collapsed' : ''}">
                        ${[...data.systemNotes].sort((a, b) => {
                            const aTime = a.modified ? new Date(a.modified).getTime() : 0;
                            const bTime = b.modified ? new Date(b.modified).getTime() : 0;
                            return bTime - aTime;
                        }).map(note => renderCard('_system', note)).join('')}
                    </div>
                </div>
                `;
            }

            content.innerHTML = sectionsHtml;

            // Apply syntax highlighting only to unhighlighted code blocks
            document.querySelectorAll('pre code:not([data-highlighted])').forEach(block => {
                hljs.highlightElement(block);
            });
        }

        function findNote(sectionId, noteId) {
            const section = data.sections.find(s => s.id === sectionId);
            if (!section) return null;
            return section.items.find(n => n.id === noteId);
        }

        function findCode(sectionId, codeId) {
            const section = data.sections.find(s => s.id === sectionId);
            if (!section) return null;
            return section.items.find(c => c.id === codeId);
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ========== SECTION: EVENT_HANDLERS_AND_INIT ==========
        // Keyboard shortcuts, modal close handlers, internal link delegation, initialization

        // Handle Enter key in modals
        document.getElementById('sectionName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') createSection();
        });

        // Generic editor keyboard handling (Phase 3)
        document.getElementById('editorModal').addEventListener('keydown', (e) => {
            // Tab in code editors
            if (e.key === 'Tab' && e.target.classList.contains('code-editor')) {
                e.preventDefault();
                const start = e.target.selectionStart;
                const end = e.target.selectionEnd;
                e.target.value = e.target.value.substring(0, start) + '    ' + e.target.value.substring(end);
                e.target.selectionStart = e.target.selectionEnd = start + 4;
            }
            // Ctrl/Cmd+Enter to save
            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                saveEditor();
            }
            // Ctrl/Cmd+S to save
            if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                saveEditor();
            }
        });

        // Close modals on overlay click
        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.classList.remove('active');
                }
            });
        });

        // Close modals on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSectionModal();
                closeEditor();
                closeViewer();
            }
        });

        // Event delegation for internal links (only in viewer modals, not in card previews)
        document.addEventListener('click', (e) => {
            const link = e.target.closest('.internal-link[data-link-section][data-link-item]');
            if (link) {
                // Only handle clicks if the link is inside a viewer modal
                const isInViewer = link.closest('#viewerModal');
                if (isInViewer) {
                    e.preventDefault();
                    e.stopPropagation();
                    const sectionId = link.dataset.linkSection;
                    const itemId = link.dataset.linkItem;
                    navigateToItem(sectionId, itemId);
                }
            }
        });

        // Initialize
        async function init() {
            // Restore UI state from sessionStorage
            restoreCollapsedSections();

            // Try to restore filesystem link first
            await initFilesystem();

            if (filesystemLinked) {
                // Filesystem data already loaded in initFilesystem, just render
                render();
            } else {
                // No folder linked - show onboarding
                showOnboarding();
            }
        }
        init();
    </script>
</body>
</html>
